/* ======================= Program Header ======================================
 PROGRAM-NAME   : PKG3071G(초과근무수당  계산/월별집계)
 SYSTEM-NAME    : 급여
 SUBSYSTEM-NAME : 수당
 Programmer     : 이상문
 Version        : 1.00
 Date           : 2018.06.14

Update Contents
 Version  date(yy.mm.dd)  programmer       description                        relevant doc.no
 1.00     2018.06.14      이상문           자율 근무제 도입에 의한 리뉴얼
 ============================================================================= */
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <math.h>
#include <ctype.h>
#include <time.h>
#include "hinsa_macro.h"
#include "hinsa_string.h"
#include "hinsa_date.h"
#include "hinsa_log.h"
#include "hinsa_oracle.h"
#include "hinsa_common.h"

/*#define  SUCCESS     -1*/
#define  FAIL        -2
#define  FRTIME1  "2200"   /* 야간근무시작시간    */
#define  TOTIME1  "3000"   /* 야간근무종료시간(익일06:00)  */
#define  FRTIME2  "4600"   /* 야간근무시작시간(익일22:00)   */
#define  TOTIME2  "4800"   /* 야간근무종료시간(익일24:00)  */

#define  SUMDATE  "20180801"  /* 자율 근무제 집계 반영 날짜 */
#define  CALDATE  "20180701"  /* 자율 근무제 시간계산 반영 날짜 */

/*** 함수 Prototype 선언  ***/
void    get_lastsaturday(char* yymm, char* lastsaturday);
void    get_dayname(char *indate,char *result);
void    get_lastday(char* yymm, char* result);
void    add_days(char* indate,int m, char* rdate);
double  calc_term(char *frdate,char *todate);
void    trail_spaces(char *dest);

/****** log File 관련 ******/
void    CreateLog();
void    WriteLog(char *message);

/*********************************************
  Global Variable
**********************************************/

EXEC SQL BEGIN DECLARE SECTION;

/***  초과근무이력테이블(PKHOTHIS) 참조변수  ***/
     char    ovtmdate[9]      = "";  /* 근무일자   */
     char    empno[5]         = "";  /* 사번     */
     char    korname[13]      = "";  /* 성명     */
     char    paycl[4]         = "";  /* 직급     */
     double  paygr            = 0;   /* 호봉     */
     char    payra[4]         = "";  /* 직위     */
     char    orgnum[4]        = "";  /* 조직차수   */
     char    deptcode[7]      = "";  /* 부서코드   */
     char    otkind[3]        = "";  /* 초과근무구분   */
     char    daykind[2]       = "";  /* 근무일구분   */
     char    frapptime[5]     = "";  /* 근무예정시간From  */
     char    toapptime[5]     = "";  /* 근무예정시간To  */
     char    toappdate[9]     = "";  /* 근무예정일To   */
     char    ovtmdesc[31]     = "";  /* 근무내역   */
     char    frrealtime[13]   = "";  /* 실제개시시간   */
     char    torealtime[13]   = "";  /* 실제종료시간   */
     float   exthh            = 0;   /* 연장근로시간   */
     double  nighthh          = 0;   /* 야간근로시간   */
     double  holihh           = 0;   /* 휴일근로시간   */
     double  overhh           = 0;   /* 초과근무시간계  */
     float   ovtmhh           = 0;   /* 초과근무시간총계  */
     float   genext           = 0;   /* 일반연장근로시간  */
     double  holiext          = 0;   /* 휴일연장근로시간  */
     char    apptime[13]      = "";  /* 신청시각   */
     char    conyn[2]         = "";  /* 결재여부   */
     char    contime[13]      = "";  /* 결재일시   */
     char    conemp[5]        = "";  /* 결재자사번   */
     char    conlemp[5]       = "";  /* 최종결재자사번  */
     char    conltime[13]     = "";  /* 최종결재일시   */
     char    otflag[2]        = "";  /* 초과근무구분(G:정상,O:초근) */
     double  ovtmrate         = 0;   /* 초과근무비율   */
     double  extamt           = 0;   /* 연장근로수당   */
     double  nightamt         = 0;   /* 야간근로수당   */
     double  holiamt          = 0;   /* 휴일근로수당   */
     double  overamt          = 0;   /* 초과근무수당계  */
     double  ovtmamt          = 0;   /* 초과근무수당총계  */
     double  ovmcamt          = 0;
     double  ovminamt         = 0;   /* 기준통상임금(최저) 적용 (2008.02.18 추가)     */
     double  y_manrate        = 0;   /* 일반직 관리수수료율  (2008.03.20 추가),통상임금 계산시 사용     */
     char    tjobduty[3]      = "";  /* 담당직무  E1,H1 변경 KTH   */
     char    dinner[2]        = "";  /* 석식장소   */

     double  totpay    = 0;
     double  tongpay   = 0;

     /* 지급 항목 */
     double  t_nighthh     = 0;  /* 야간근로시간   */
     float   t_genexthh     = 0;  /* 일반연장근로시간  */
     double  t_holihh      = 0;  /* 휴일근로시간   */
     double  t_holiexthh   = 0;  /* 휴일연장근로시간  */
     double  t_extamt      = 0;  /* 연장근로수당   */
     double  t_nightamt    = 0;  /* 야간근로수당   */
     double  t_holiamt     = 0;  /* 휴일근로수당   */

     /* 제외 항목 */
     int     t_restmm      = 0;  /* 초과근무제외시간  */
     double  t_restamt     = 0;  /* 초과근무제외수당  */
     int     t_sprestmm    = 0;  /* 근무시간에 휴식한 제외시간  */
     double  t_sprestamt   = 0;  /* 근무시간에 휴식한 제외수당  */

     double  t_mealhh      = 0;  /* 식사시간제외시간           */
     double  t_excephh     = 0;  /* 9시간이상시 제외시간   */
     double  t_mealamt     = 0;  /* 식사시간제외수당             */
     double  t_excepamt    = 0;  /* 9시간이상시 제외수당   */

     double  s_totdd;
     float   s_exthh;
     double  s_nighthh;
     double  s_holihh;
     double  s_tothh;
     float   s_genext;
     double  s_holiext;
     double  s_extamt;
     double  s_nightamt;
     double  s_holiamt;
     double  s_ovtmamt;
     double  s_ovmcamt;
     float   s_ovtmhh;

     char    workmm[7]       = "";  /* 작업년월   */
     char    frempno[5]      = "";  /* 사번FROM   */
     char    toempno[5]      = "";  /* 사번TO   */
     char    totalYN[2]      = "";  /* 집계여부   */
     char    jobempno[5]     = "";  /* 작업자사번   */
     char    sumkind[2]      = "";  /* 집계형태   */
     int     rephh           = 0 ;  /*대휴기준시간*/
     char    comchdate[9]    = "";  /* 통상임금기준변경일 2014.11 jissi */
     char    yearpaynum[7]   = "";  /* 반영연봉차수       2016.12 jissi */

     char    t_paycl[4]      = "";

     long    s_count         = 0;
     long    f_count         = 0;
     double  total_amt       = 0;

     /* 초과근무수당 계산번경(10분단위 절사, 잔여분 이월 - 2017.11.20 SangMoon Lee */
     /* 10분단위 계산위한 분단위 변수 */
     int     t_extmm         = 0;   /* 연장근로분 */
     int     t_nightmm       = 0;   /* 야간근로분 */
     int     t_holimm        = 0;   /* 휴일근로분 */
     int     t_genextmm      = 0;   /* 일반연장근로분 */
     int     t_holiextmm     = 0;   /* 휴일연장근로분 */
     int     t_mealmm        = 0;   /* 식사시간제외분 */

     int     pre_genextsum   = 0;   /* 전,당월 일반연장합 */
     int     pre_holiextsum  = 0;   /* 전,당월 휴일연장합 */
     int     pre_nightsum    = 0;   /* 전,당월 야간근로합 */
     int     pre_holisum     = 0;   /* 전,당월 휴일근로합 */
     int     pre_mealsum     = 0;   /* 전,당월 식사시간합 */
     int     pre_restsum     = 0;   /* 전,당월 초과근무제외합 */
     int     pre_sprestsum   = 0;   /* 전,당월 근로시간휴식제외합 */

     int     nxt_extmm       = 0;   /* 이월 연장근로분 */
     int     nxt_nightmm     = 0;   /* 이월 야간근로분 */
     int     nxt_holimm      = 0;   /* 이월 휴일근로분 */
     int     nxt_genextmm    = 0;   /* 이월 일반연장근로분 */
     int     nxt_holiextmm   = 0;   /* 이월 휴일연장근로분 */
     int     nxt_mealmm      = 0;   /* 이월 식사시간제외분 */
     int     nxt_restmm      = 0;   /* 이월 초과근무제외시간 */
     int     nxt_sprestmm    = 0;   /* 이월 근무시간에 휴식한 제외시간 */

     /* 일일 시간 계산(pkg3075g) 변수 - 2018.06.21 Sangmoon Lee */
     char    frworkdate[9]     = "";   /* 작업년월일 fr  */
     char    toworkdate[9]     = "";   /* 작업년월일 to  */
     char    workmon[6+1];
     
     char    curdate[9];

EXEC SQL END DECLARE SECTION;
EXEC SQL INCLUDE SQLCA;

/******************************************************************************
  Other Variables
******************************************************************************/
char  LSaturday[8+1]  = "";
char  mm[3] = "";
int   id;

/*=== dsa2000 2004.11. Rexec대체 서비스를 위한 =============*/
char  log_rundate[16]     = "";
char  log_progid[16]      = "";
char  log_writeman[5]     = "";
char  log_buff[100]       = "";
int   seqno = 0;

/* 집계(pkg3070g)와 일일 시간 계산(pkg3075g) 일원화 구분자 추가 - 2018.06.20 Sangmoon Lee */
char  sumYN[2] = "";

/* 일일 시간 계산(pkg3075g) 로그 파일을 위한 - 2018.06.20 Sangmoon Lee */
/****** log File 관련 ******/
char  logfile_fullname[140];

/***** Log Filspeciale Pointer *****/
FILE  *fp;

void main(int argc,char *argv[])
{
     int  flag;
     char FL_file[255];
     char  curdatetime[20+1]="";


     /*dsa2000 Rexec 대체 파라미터 추가...*/
     if  (argc != 11) {  /*/hper/insa/HINSA/proc/bin/Kbin/pkg3070g 201509 0000 zzzz Y 0 2563 pkg3070g 20151007140600 201601 Y*/
          printf("[Usage] : pkg3071g 1.작업월 2.사번fr 3.사번to 4.집계방법(전체Y, 일부N) \n");
          printf("[Usage] :          5.집계방법(전체0, 일부1) 6.작업자사번 7.프로그램ID \n");
          /* 집계(pkg3070g)와 일일 시간 계산(pkg3075g) 일원화 구분자 추가 - 2018.06.20 Sangmoon Lee */
          printf("[Usage] :          8.시작시간 9.반영연봉차수 10.집계여부(집계Y, 시간N) \n");
          exit(1);
     }
     
     /* Parameter */
     strcpy(workmm,argv[1]);
     strcpy(frempno,argv[2]);
     strcpy(toempno,argv[3]);
     strcpy(totalYN,argv[4]);
     strcpy(sumkind,argv[5]);
     strcpy(jobempno,argv[6]);
     strcpy(yearpaynum,argv[9]);

     /* 집계(pkg3070g)와 일일 시간 계산(pkg3075g) 일원화 구분자 추가 - 2018.06.20 Sangmoon Lee */
     strcpy(sumYN, argv[10]);


     /* 집계(pkg3070g)와 일일 시간 계산(pkg3075g) 일원화 구분자 추가 - 2018.06.21 Sangmoon Lee */
     if (strcmp(sumYN, "Y") == 0)
     {
          /*로그 디렉토리 생성 및 로그작업 */
          STRINIT(FL_file);
          strcpy(FL_file,"pkg3071g_Y");
          
          hinsa_get_filename(1, FL_file);
          if  (hinsa_log_open(FL_file) == FAILURE)
          {
               hinsa_exit(0,"로그파일 생성에러로 인한 프로그램 종료...");
               return;
          }
          
          hinsa_log_print(0,"초과근무수당 생성/계산 시작...[pkg3071g_Y]");
     }
     else if (strcmp(sumYN, "N") == 0)
     {
          /*로그 디렉토리 생성 및 로그작업 */
          STRINIT(FL_file);
          strcpy(FL_file,"pkg3071g_N");
          
          hinsa_get_filename(1, FL_file);
          
          hinsa_log_print(0,"초과근무수당 생성/계산 시작...[pkg3071g_N]");
     }
     
     hinsa_db_connect();  /*DB Connect 실시..*/

     EXEC SQL
     SELECT  to_char(sysdate, 'YYYYMMDD')
       INTO  :curdate
       FROM  DUAL ;
     
     /*printf("curdate=%s, sumdate=%s, compare1=%d, compare2=%d, compare2=%d \n"
           ,curdate, SUMDATE, strcmp(curdate, SUMDATE), strcmp("20180801", SUMDATE), strcmp("20180802", SUMDATE));*/
     //hinsa_exit(0," 개발자 종료. !!!\n");

     /*=== dsa2000 2004.11. Rexec대체 서비스를 위한 =============*/
     strcpy(log_writeman, argv[6]);
     strcpy(log_progid,   argv[7]);
     
     EXEC SQL DECLARE log_db DATABASE;
     hinsa_log_db_connect();
     
     /* 집계(pkg3070g)와 일일 시간 계산(pkg3075g) 일원화 구분자 추가 - 2018.06.21 Sangmoon Lee */
     if (strcmp(sumYN, "Y") == 0)
     {
          strcpy(log_rundate,  argv[8]);
     }
     else if (strcmp(sumYN, "N") == 0)
     {
          EXEC SQL
          SELECT to_char(add_months(to_date(FIXMON, 'YYYYMM'),1), 'YYYYMM') 
            INTO  :workmon
            FROM PKCOTBAS ;
          
          EXEC SQL
          SELECT  :workmon||'01',  to_char(sysdate, 'YYYYMMDD')
            INTO  :frworkdate,:toworkdate
            FROM  DUAL ;
          
          strcpy(log_rundate,  toworkdate);
          
          sprintf(frworkdate,"%.8s",frworkdate);
          sprintf(toworkdate,"%.8s",toworkdate);
          
          CreateLog();
     
          sprintf(log_buff, "작업년월일fr ~ to : %s ~ %s\n", frworkdate, toworkdate);
          WriteLog(log_buff);
          Write_batlog(seqno++, log_buff); /*dsa2000 Rexec 대체*/
          
          sprintf(log_buff, "사번fr ~ to : %s ~ %s\n", argv[1], argv[2]);
          WriteLog(log_buff);
          Write_batlog(seqno++, log_buff); /*dsa2000 Rexec 대체*/
          
          sprintf(log_buff, "작업자사번 : %s\n", argv[3]);
          WriteLog(log_buff);
          Write_batlog(seqno++, log_buff); /*dsa2000 Rexec 대체*/
          
          sprintf(log_buff, "  ");
     }
     /* 통상임금기준변경일 2014.11 jissi */
     EXEC SQL
     SELECT  value1
       INTO  :comchdate
       FROM PKCVARI
      WHERE gubun ='CM';

     /*========================================================*/

     EXEC SQL LOCK TABLE PKHOTHIS
       IN   EXCLUSIVE  MODE  NOWAIT;


     if  (clear_records() != SUCCESS)
     {
          sprintf(log_buff, "= 작업실패 ="); /*dsa2000 Rexec 대체*/
          Write_batlog(seqno++, log_buff);
          hinsa_exit(0," 작업실패. !!!\n");
     }

     
     
     /* 집계(pkg3070g)와 일일 시간 계산(pkg3075g) 일원화 구분자 추가 - 2018.06.21 Sangmoon Lee */
     if (strcmp(sumYN, "Y") == 0)
     {
          s_count = f_count = total_amt =  0;
          
          rephh = 8 ; /*대휴기준시간*/
          
          /*정규직 초과근무 계산*/
          /* 자율 근무제 집계는 2018.08.01부터 가능 - 2018.06.29 Sangmoon Lee */
          if (strcmp(curdate, SUMDATE) < 0)
          {
               flag =  process_records_old();
          }
          else
          {
               flag =  process_records();
          }
          
          printf("\n 정규직 ====================================");
          sprintf(log_buff, "\n 정규직 ===================================="); /*dsa2000 Rexec 대체*/
          Write_batlog(seqno++, log_buff);
          
          printf("\n (%ld)건에 대해서 초과근무시간 계산 성공.\n",s_count);
          sprintf(log_buff, "\n (%ld)건에 대해서 초과근무시간 계산 성공.\n",s_count); /*dsa2000 Rexec 대체*/
          Write_batlog(seqno++, log_buff);
          
          printf("\n (%ld)건에 대해서 초과근무시간 계산 실패.\n",f_count);
          sprintf(log_buff, "\n (%ld)건에 대해서 초과근무시간 계산 실패.\n",f_count); /*dsa2000 Rexec 대체*/
          Write_batlog(seqno++, log_buff);
          
          printf("\n 총수당액 : %10.0f \n",total_amt);
          sprintf(log_buff,"\n 총수당액 : %10.0f \n",total_amt); /*dsa2000 Rexec 대체*/
          Write_batlog(seqno++, log_buff);
          
          
          s_count = f_count = total_amt =  0;
          
          
          /*계약직 초과근무 계산*/
          flag =  process_records_con();
          
          printf("\n 계약직 ====================================");
          sprintf(log_buff, "\n계약직 ===================================="); /*dsa2000 Rexec 대체*/
          Write_batlog(seqno++, log_buff);
          
          printf("\n (%ld)건에 대해서 초과근무시간 계산 성공.\n",s_count);
          sprintf(log_buff,"\n (%ld)건에 대해서 초과근무시간 계산 성공.\n",s_count); /*dsa2000 Rexec 대체*/
          Write_batlog(seqno++, log_buff);
          
          printf("\n (%ld)건에 대해서 초과근무시간 계산 실패.\n",f_count);
          sprintf(log_buff,"\n (%ld)건에 대해서 초과근무시간 계산 실패.\n",f_count); /*dsa2000 Rexec 대체*/
          Write_batlog(seqno++, log_buff);
          
          printf("\n 총수당액 : %10.0f \n",total_amt);
          sprintf(log_buff,"\n 총수당액 : %10.0f \n",total_amt); /*dsa2000 Rexec 대체*/
          Write_batlog(seqno++, log_buff);
          
          printf("\n totalYN : [%s] flag [%d] \n",totalYN,flag);
          
          process_sumstep1();
          
          print_Lastamt();
          
          /* ===============================================================================
           Version  date(yy.mm.dd)  programmer    description                        relevant doc.no
           30.30    2001.11.13.      유효성       근태테이블(pkhduty)의 대휴(repoff)및 교휴(speoff)  를 불러와
                                                  최종계산된 초과수당(pkhotsum의 ovtmamt)에서 빼는 로직 추가.
           ============================================================================= */
          if  (process_repoff() != SUCCESS )
          {
               sprintf(log_buff,"대휴수당 계산작업 실패"); /*dsa2000 Rexec 대체*/
               Write_batlog(seqno++, log_buff);
               error_quit("작업이 실패했습니다.\n");
          }
          
          /* Dsa2000  2004.02.25.  hinsa_exit()에서 DB Commit & DB접속종료함.*/
          if  (sqlca.sqlcode != 0 && sqlca.sqlcode != 1403)
          {
               sprintf(log_buff, "ERROR ====== [작업 실패] ====="); /*dsa2000 Rexec 대체*/
               Write_batlog(seqno++, log_buff);
               error_quit("ERROR ====== [작업 실패] =====\n");
          }
          else
          {
               sprintf(log_buff, "OK ====== [작업 성공] ====="); /*dsa2000 Rexec 대체*/
               Write_batlog(seqno++, log_buff);
               hinsa_exit(0,"OK ====== [작업 성공] =====\n");
          }
     }
     else if (strcmp(sumYN, "N") == 0)
     {
          s_count = f_count = total_amt =  0;
          
          /* 자율 근무제 시간 계산은 2018.07.01부터 가능 - 2018.06.29 Sangmoon Lee */
          if (strcmp(curdate, CALDATE) < 0)
          {
              flag =  process_records_N_old();
          }
          else
          {
              flag =  process_records_N();
          }
          
          printf(log_buff,"\n (%ld)건에 대해서 초과근무시간 계산 성공.\n",s_count);
          sprintf(log_buff,"\n (%ld)건에 대해서 초과근무시간 계산 성공.\n",s_count);
          WriteLog(log_buff);
          Write_batlog(seqno++, log_buff);  /*dsa2000 Rexec 대체*/
          
          printf(log_buff,"\n (%ld)건에 대해서 초과근무시간 계산 실패.\n",f_count);
          sprintf(log_buff,"\n (%ld)건에 대해서 초과근무시간 계산 실패.\n",f_count);
          WriteLog(log_buff);
          Write_batlog(seqno++, log_buff); /*dsa2000 Rexec 대체*/
          
          printf(log_buff," 총수당액 : %10.0f 원\n",total_amt);
          sprintf(log_buff," 총수당액 : %10.0f 원\n",total_amt);
          WriteLog(log_buff);
          Write_batlog(seqno++, log_buff); /*dsa2000 Rexec 대체*/
          
          /*** 종료시간 Print dsa2000 Add ***************************/
          EXEC SQL  
          SELECT TO_CHAR(SYSDATE,'YYYYMMDDHH24MISS')
            INTO :curdatetime
            FROM DUAL;
          
          sprintf(log_buff, "종료시간 : %.14s \n ",curdatetime);
          WriteLog(log_buff);
          Write_batlog(seqno++, log_buff); 
          /*********************************************************/
          
          if  (flag != SUCCESS)
          {
               sprintf(log_buff,"작업이 실패했습니다.\n");
               WriteLog(log_buff);
               Write_batlog(seqno++, log_buff); /*dsa2000 Rexec 대체*/
               error_quit("작업이 실패했습니다.\n");
          }
          else
          {
               sprintf(log_buff,"작업이 성공적으로 완료되었습니다.\n");
               WriteLog(log_buff);
               Write_batlog(seqno++, log_buff); /*dsa2000 Rexec 대체*/
               hinsa_exit(0,"OK 작업이 성공적으로 완료되었습니다.\n");
          }
     }
}

/*****************************************************************************
  계산 전 해당항목을 Clear하는 함수.
 *****************************************************************************/
clear_records()
{
     ovminamt  = 0; /* 통상임금이 시간당 최저 임금보다 낮을 경우 최저임금으로 계산 */
     y_manrate = 0;/* 일반직 통상임금 계산시 관리수수료율 사용 */

     /* 집계(pkg3070g)와 일일 시간 계산(pkg3075g) 일원화 구분자 추가 - 2018.06.20 Sangmoon Lee */
     if (strcmp(sumYN, "Y") == 0)
     {

         EXEC SQL
         SELECT   nvl(OVMINAMT,0)
           INTO   :ovminamt
           FROM   PKCOTBAS;

         EXEC SQL
         SELECT   nvl(Y_MANRATE,0)
           INTO   :y_manrate
           FROM   PKCPBAS;

         EXEC SQL
         UPDATE  PKHOTHIS
            SET  EXTHH    = 0,  NIGHTHH   = 0,  HOLIHH   = 0,
                 OVTMHH   = 0,  OVMCAMT   = 0,  GENEXT   = 0,
                 HOLIEXT  = 0,  EXTAMT    = 0,  NIGHTAMT = 0,
                 HOLIAMT  = 0,  OVTMAMT   = 0,  RESTAMT  = 0,
                 SPRESTAMT= 0,  MEALHH    = 0,  MEALAMT  = 0,
                 EXCEPHH  = 0,  EXCEPAMT  = 0
          WHERE  SUBSTR(OVTMDATE,1,6) = :workmm
            AND  (EMPNO >= :frempno AND EMPNO <= :toempno ) ;

         if ((sqlca.sqlcode != 1403) && (sqlca.sqlcode != 0))
         {
              printf("ERROR_CODE : %d, 자료 Clear Error. \n", sqlca.sqlcode);
              sprintf(log_buff, "ERROR_CODE : %d, 자료 Clear Error. \n", sqlca.sqlcode); /*dsa2000 Rexec 대체*/
              Write_batlog(seqno++, log_buff);
              return(FAIL);
         }

         /*2002.6.17 유효성 추가 */
         EXEC SQL
         DELETE  FROM PKHOTSUM
          WHERE (EMPNO >= :frempno AND EMPNO <= :toempno)
            AND OVTMYYMM = :workmm;

         if ((sqlca.sqlcode != 1403) && (sqlca.sqlcode != 0))
         {
              printf("ERROR_CODE : %d, 자료 Delete Error. \n", sqlca.sqlcode);
              sprintf(log_buff, "ERROR_CODE : %d,  자료 Delete Error. \n", sqlca.sqlcode); /*dsa2000 Rexec 대체*/
              Write_batlog(seqno++, log_buff);
              return(FAIL);
         }
         else
              return(SUCCESS);
     }
     else if (strcmp(sumYN, "N") == 0)
     {
         EXEC SQL
         SELECT to_char(add_months(to_date(FIXMON, 'YYYYMM'),1), 'YYYYMM') 
           INTO  :workmon
           FROM PKCOTBAS ;
         
         EXEC SQL
         SELECT  :workmon||'01',  to_char(sysdate, 'YYYYMMDD')
           INTO  :frworkdate,:toworkdate
           FROM  DUAL ;
       
         EXEC SQL
         SELECT  nvl(OVMINAMT,0)
           INTO  :ovminamt
           FROM  PKCOTBAS;

         EXEC SQL
         SELECT  nvl(Y_MANRATE,0)
           INTO  :y_manrate
           FROM  PKCPBAS;

         EXEC SQL
         UPDATE  PKHOTHIS
            SET
                 EXTHH      = 0,
                 NIGHTHH    = 0,
                 HOLIHH     = 0,
                 OVTMHH     = 0,
                 OVMCAMT    = 0,
                 GENEXT     = 0,
                 HOLIEXT    = 0,
                 EXTAMT     = 0,
                 NIGHTAMT   = 0,
                 HOLIAMT    = 0,
                 OVTMAMT    = 0,
                 RESTAMT    = 0,
                 SPRESTAMT  = 0,
                 WRITETIME  = '***',
                 MEALHH     = 0,
                 MEALAMT    = 0,
                 EXCEPHH    = 0,
                 EXCEPAMT   = 0
          WHERE  OVTMDATE BETWEEN  :frworkdate AND :toworkdate
            AND  EMPNO BETWEEN  :frempno and :toempno
            AND  PAYCL IS null;    /* Dsa2000 2003.12.05  deptcode is null */

         if ((sqlca.sqlcode != 1403) && (sqlca.sqlcode != 0))
         {
              sprintf(log_buff,"ERROR_CODE : %d, 자료 Clear Error. \n", sqlca.sqlcode);
              WriteLog(log_buff);
              return(FAIL);
         }
         else
              return(SUCCESS);
     }
}

/*****************************************************************************
  대상자료를 추출하는 함수.== 계약직사원
 *****************************************************************************/
process_records_con()
{
     char  t_date[11]   = "";
     int   term = 0;
     char  stime[5] = "";
     char  etime[5] = "";
     int   daykind  = 0;
     char  str[8+1]   = "";
     int   dd   = 0;

     EXEC SQL DECLARE cursor_2 CURSOR FOR
     SELECT
            NVL(OVTMDATE,' '), NVL(A.EMPNO,' '),
            NVL(A.KORNAME,' '),NVL(D.PAYCL,' '),
            NVL(FRAPPTIME,'*'), NVL(FRREALTIME,'*'),
            NVL(TOREALTIME,'*'), totpay,
            nvl(restmm, 0), nvl(sprestmm, 0),NVL(TRIM(TJOBDUTY),' '),
            NVL(A.OTFLAG,' ') /* 초과근무 구분 추가 - Sangmoon Lee 2018.06.14 */
      FROM  PKHOTHIS A, PKHYPHIS B, PIMPMAS D
     WHERE  (SUBSTR(OVTMDATE,1,6) = :workmm)
       AND  (A.EMPNO >= :frempno AND A.EMPNO <= :toempno )
       AND  (B.YEARPAYNUM = :yearpaynum  )
       AND  (A.EMPNO = B.EMPNO)
       AND  (B.EMPNO = D.EMPNO)
       AND  (UPPER(NVL(CONYN,' ')) = 'Y' )
/*infra   AND  A.PAYCL >='99'  */
       AND  D.PAYCL >='D91'
     ORDER  BY A.EMPNO, OVTMDATE;

     EXEC SQL OPEN cursor_2;
     if ((sqlca.sqlcode != 1403) && (sqlca.sqlcode != 0) && (sqlca.sqlcode != -1405))
     {
          printf("ERROR_CODE : %d, cursor_2 Open Error\n", sqlca.sqlcode);
          sprintf(log_buff, "ERROR_CODE : %d,  cursor_2 Open Error. \n", sqlca.sqlcode); /*dsa2000 Rexec 대체*/
          Write_batlog(seqno++, log_buff);
          EXEC SQL CLOSE cursor_2;
          return(FAIL);
     }

     while(1)
     {
          EXEC SQL FETCH cursor_2
             INTO :ovtmdate,   :empno,      :korname, :paycl,
                  :frapptime,  :frrealtime,
                  :torealtime, :totpay,  :t_restmm ,  :t_sprestmm,  :tjobduty,
                  :otflag /* 초과근무 구분 추가 - Sangmoon Lee 2018.06.14 */
                  ;
          if  (sqlca.sqlcode == 1403)
          {
               EXEC SQL CLOSE cursor_2;
               return(SUCCESS);
          }

          trail_spaces(frapptime);
          trail_spaces(frrealtime);
          trail_spaces(torealtime);
          trail_spaces(paycl);

          t_nighthh   = 0;
          t_genexthh  = 0;
          t_holihh    = 0;
          t_holiexthh = 0;
          t_mealhh    = 0;
          t_excephh   = 0;

          t_extmm     = 0;
          t_nightmm   = 0;
          t_holimm    = 0;
          t_genextmm  = 0;
          t_holiextmm = 0;
          t_mealmm    = 0;

          strncpy(str,frrealtime,8);

          /* ========================================
          심야근로, 식사시간
          ========================================  */

          if ((get_nighthh(frrealtime,torealtime) == SUCCESS) &&
              (get_genexthh_con(frrealtime, torealtime) == SUCCESS) &&
              (process_holihh(frrealtime,torealtime) == SUCCESS) &&       /* 정규직과 일반직 사원 휴일 수당 동일 하게 계산 작업 kth*/
              (get_mealhh_con(frrealtime, torealtime) == SUCCESS) &&      /* 정규직, 계약직 식사시간 분리 - 2018.02.08 SangMoon Lee */
              (get_excepthh(frrealtime, torealtime)== SUCCESS))
          {
               if  (update_record() != SUCCESS)
               {
                    printf(" EMPNO : %s, KORNAME : %s \n ", empno,korname);
                    /*sprintf(log_buff, "EMPNO : %s, KORNAME : %s \n ", empno,korname); dsa2000 Rexec 대체*/
                              /*Write_batlog(seqno++, log_buff);*/
                    strncpy(t_date,ovtmdate,4);
                    t_date[4] = '-';
                    strncpy(t_date+5,ovtmdate+4,2);
                    t_date[7] = '-';
                    strncpy(t_date+8,ovtmdate+6,2);
                    t_date[10] = '\0';
                    printf(" 초과근무일자 : %s \n",t_date);
                    printf(" BAND : %s \n",paycl);
               }
               s_count++;
          }
          else
          {
               f_count++;
               printf(" 계산에 실패한 EMPNO : %s, KORNAME : %s \n ", empno,korname);
               /*sprintf(log_buff, " 계산에 실패한 EMPNO : %s, KORNAME : %s \n ", empno,korname); dsa2000 Rexec 대체*/
                        /*Write_batlog(seqno++, log_buff);*/
               strncpy(t_date,ovtmdate,4);
               t_date[4] = '-';
               strncpy(t_date+5,ovtmdate+4,2);
               t_date[7] = '-';
               strncpy(t_date+8,ovtmdate+6,2);
               t_date[10] = '\0';
               printf(" 초과근무일자 : %s \n",t_date);
          }
     }
}

/*****************************************************************************
  대상자료를 추출하는 함수.== 정규사원
 *****************************************************************************/
process_records()
{
     char  t_date[11]   = "";

     EXEC SQL
     UPDATE  PKHOTHIS A
        SET (PAYCL,PAYGR,PAYRA,ORGNUM,DEPTCODE )=
          (SELECT B.PAYCL,B.PAYGR,B.PAYRA,B.ORGNUM,B.DEPTCODE
                 FROM   PKMPMAS B
                 WHERE A.EMPNO = B.EMPNO
          )
     WHERE  SUBSTR(OVTMDATE,1,6) = :workmm
       AND  (A.EMPNO >= :frempno AND A.EMPNO <= :toempno )
       AND  UPPER(NVL(CONYN,' ')) = 'Y';

     if ((sqlca.sqlcode != 1403) && (sqlca.sqlcode != 0))
     {
          printf("ERROR_CODE : %d, 인사자료 SETTING Error. \n", sqlca.sqlcode);
          sprintf(log_buff, "ERROR_CODE : %d, 인사자료 SETTING Error. \n", sqlca.sqlcode); /*dsa2000 Rexec 대체*/
          Write_batlog(seqno++, log_buff);
     }

     EXEC SQL DECLARE cursor1 CURSOR FOR
     SELECT
             NVL(OVTMDATE,' '), NVL(A.EMPNO,' '),
             NVL(A.KORNAME,' '),NVL(A.PAYCL,' '),
             NVL(FRAPPTIME,'*'), NVL(FRREALTIME,'*'),
             NVL(TOREALTIME,'*'), totpay,
             NVL(RESTMM,0),NVL(SPRESTMM,0),
             NVL(A.OTFLAG,' ') /* 초과근무 구분 추가 - Sangmoon Lee 2018.06.14 */
       FROM  PKHOTHIS A, PKHYPHIS B
      WHERE  (SUBSTR(OVTMDATE,1,6) = :workmm)
        AND  (A.EMPNO >= :frempno AND A.EMPNO <= :toempno )
        AND  (B.YEARPAYNUM = :yearpaynum)
        AND  (A.EMPNO = B.EMPNO)
        AND  (UPPER(NVL(CONYN,' ')) = 'Y' )
        AND  PAYCL <='D41'      /*infra   PAYCL <='99' */
      ORDER  BY A.EMPNO, OVTMDATE;

     EXEC SQL OPEN cursor1;
     if ((sqlca.sqlcode != 1403) && (sqlca.sqlcode != 0) && (sqlca.sqlcode != -1405))
     {
          printf("ERROR_CODE : %d, Cursor1 Open Error\n",  sqlca.sqlcode);
          sprintf(log_buff, "ERROR_CODE : %d, Cursor1 Open Error. \n", sqlca.sqlcode); /*dsa2000 Rexec 대체*/
          Write_batlog(seqno++, log_buff);
          EXEC SQL CLOSE cursor1;
          return(FAIL);
     }

     while(1)
     {
          EXEC SQL FETCH cursor1
             INTO :ovtmdate, :empno, :korname, :paycl,
                  :frapptime,:frrealtime,
                  :torealtime, :totpay, :t_restmm,:t_sprestmm,
                  :otflag /* 초과근무 구분 추가 - Sangmoon Lee 2018.06.14 */
                  ;
          if (sqlca.sqlcode == 1403) {
            EXEC SQL CLOSE cursor1;
            return(SUCCESS);
          }

          trail_spaces(frapptime);
          trail_spaces(frrealtime);
          trail_spaces(torealtime);
          trail_spaces(paycl);

          t_nighthh   = 0;
          t_genexthh  = 0;
          t_holihh    = 0;
          t_holiexthh = 0;
          t_mealhh    = 0;
          t_excephh   = 0;

          t_extmm     = 0;
          t_nightmm   = 0;
          t_holimm    = 0;
          t_genextmm  = 0;
          t_holiextmm = 0;
          t_mealmm    = 0;


          if ( (get_nighthh(frrealtime,torealtime)    == SUCCESS) &&
               (get_genexthh(frrealtime,torealtime)   == SUCCESS) &&
               (process_holihh(frrealtime,torealtime) == SUCCESS) &&
/* ==============================================================================
 Version  date(yy.mm.dd)  programmer  description                 relevant doc.no
 30.20    2001.08.09.      유효성       휴일근무시 식사시간 제외 추가
============================================================================= */
               (get_mealhh(frrealtime, torealtime) == SUCCESS) &&
               (get_excepthh(frrealtime, torealtime)== SUCCESS) )
          {
               if  (update_record() != SUCCESS)
               {
                    printf(" EMPNO : %s, KORNAME : %s \n ", empno,korname);
                    /*sprintf(log_buff, " EMPNO : %s, KORNAME : %s \n ", empno,korname); dsa2000 Rexec 대체*/
                              /*Write_batlog(seqno++, log_buff);*/
                    strncpy(t_date,ovtmdate,4);
                    t_date[4] = '-';
                    strncpy(t_date+5,ovtmdate+4,2);
                    t_date[7] = '-';
                    strncpy(t_date+8,ovtmdate+6,2);
                    t_date[10] = '\0';
                    printf(" 초과근무일자 : %s \n",t_date);
                    printf(" BAND : %s \n",paycl);
               }
               s_count++;
          }
          else
          {
               f_count++;
               printf(" 계산에 실패한 EMPNO : %s, KORNAME : %s \n ", empno,korname);
               /*sprintf(log_buff, " 계산에 실패한 EMPNO : %s, KORNAME : %s \n ", empno,korname); dsa2000 Rexec 대체*/
                        /*Write_batlog(seqno++, log_buff);*/
               strncpy(t_date,ovtmdate,4);
               t_date[4] = '-';
               strncpy(t_date+5,ovtmdate+4,2);
               t_date[7] = '-';
               strncpy(t_date+8,ovtmdate+6,2);
               t_date[10] = '\0';
               printf(" 초과근무일자 : %s \n",t_date);
          }
     }

}
/*****************************************************************************
  대상자료를 추출하는 함수. ==  시간 계산
 *****************************************************************************/
process_records_N()
{
     char  t_date[11]   = "";
     char  maxcondate[8+1] = "";
     int   holicnt = 0;
     /*double  tongpay;*/
     
     EXEC    SQL
     UPDATE  PKHOTHIS A
        SET  (PAYCL,PAYGR,PAYRA,ORGNUM,DEPTCODE )=
             (SELECT B.PAYCL,B.PAYGR,B.PAYRA,B.ORGNUM,B.DEPTCODE
                FROM   PKMPMAS B
               WHERE A.EMPNO = B.EMPNO
             )
      WHERE  OVTMDATE BETWEEN  :frworkdate AND :toworkdate
        AND  (A.EMPNO >= :frempno AND A.EMPNO <= :toempno )
        AND  UPPER(NVL(CONYN,' ')) = 'Y'
        AND  WRITETIME  = '***';
           
     if  ((sqlca.sqlcode != 1403) && (sqlca.sqlcode != 0)) 
     {
           sprintf(log_buff,"ERROR_CODE : %d, 인사자료 SETTING Error. \n", sqlca.sqlcode);
           WriteLog(log_buff);
     }
     
     EXEC SQL DECLARE cursor4 CURSOR FOR
     SELECT  NVL(OVTMDATE,' '), NVL(A.EMPNO,' '),
             NVL(A.KORNAME,' '),NVL(A.PAYCL,' '),
             NVL(FRAPPTIME,'*'), NVL(FRREALTIME,'*'),
             NVL(TOREALTIME,'*'), totpay,
             substr(NVL(CONLTIME,'00000000'),1,8),CONLEMP,
             NVL(RESTMM,0),NVL(SPRESTMM,0),NVL(TJOBDUTY, ' '),
             case when OVTMDATE < :comchdate                                     /*2017.01.01이후 초과근무수당 계산할 때 통상임금이 기준시간 226hr->209hr*/
                  then hper.COMMONUTIL.GET_OLDBASEPAY(a.EMPNO,c.YEARPAYNUM)
                  else hper.COMMONUTIL.GET_NEWBASEPAY(a.EMPNO,c.YEARPAYNUM) end,  /*DB package에서 계산 jissi. 2016.12.14*/
             NVL(A.OTFLAG,' ') /* 초과근무 구분 추가 - Sangmoon Lee 2018.06.14 */
       FROM  PKHOTHIS A, PKHYPHIS B, PKCPBAS C, PIMPMAS D
      WHERE  OVTMDATE BETWEEN :frworkdate AND :toworkdate 
        AND  A.EMPNO >= :frempno AND A.EMPNO <= :toempno 
        AND  TO_CHAR(C.YEARPAYNUM) =  B.YEARPAYNUM 
        AND  A.EMPNO = B.EMPNO 
        AND  B.EMPNO = D.EMPNO
        AND  UPPER(NVL(CONYN,' ')) = 'Y' 
        AND  A.WRITETIME = '***'
      ORDER  BY A.EMPNO, OVTMDATE;
     
     EXEC SQL OPEN cursor4;
     
     if ((sqlca.sqlcode != 1403) && (sqlca.sqlcode != 0) &&
         (sqlca.sqlcode != -1405)) 
     {
        
          sprintf(log_buff,"In the Select ERROR_CODE : %d, Cursor4 Open Error\n", sqlca.sqlcode);
          WriteLog(log_buff);
                   
          EXEC SQL CLOSE cursor4;
          return(FAIL);
     }
     
     while(1) 
     {
          EXEC SQL FETCH cursor4
          INTO :ovtmdate, :empno, :korname, :paycl, 
               :frapptime,:frrealtime, :torealtime, :totpay,
               :conltime, :conlemp,
               :t_restmm,:t_sprestmm ,:tjobduty, :tongpay,
               :otflag /* 초과근무 구분 추가 - Sangmoon Lee 2018.06.14 */
               ;
          
          if  (sqlca.sqlcode == 1403) 
          {
               EXEC SQL CLOSE cursor4;
               return(SUCCESS);
          }
          
          trail_spaces(frapptime);
          trail_spaces(frrealtime);
          trail_spaces(torealtime);
          trail_spaces(paycl);

                 
          sprintf(log_buff,"   ");
          WriteLog(log_buff);
          
          t_nighthh   = 0;
          t_genexthh  = 0;
          t_holihh    = 0;
          t_holiexthh = 0;
          t_mealhh    = 0;
          t_excephh   = 0;

                
          if ( (get_nighthh(frrealtime,torealtime)    == SUCCESS) &&
               (get_genexthh(frrealtime,torealtime)   == SUCCESS) &&
               (process_holihh(frrealtime,torealtime) == SUCCESS) &&
/* ==============================================================================
 Version  date(yy.mm.dd)  programmer  description                relevant doc.no  
 30.20    2001.08.09.      유효성       휴일근무시 식사시간 제외 추가 
============================================================================= */
               (get_mealhh(frrealtime, torealtime) == SUCCESS) &&
               (get_excepthh(frrealtime, torealtime)== SUCCESS) ) 
          
          {
               if  (update_record() != SUCCESS) 
               {
                    sprintf(log_buff," 수당 수정 불가자 =>사번 : %s, 성명 : %s \n ",  empno,korname);
                    WriteLog(log_buff);
                   
                    strncpy(t_date,ovtmdate,4);
                    t_date[4] = '-';
                    strncpy(t_date+5,ovtmdate+4,2);
                    t_date[7] = '-';
                    strncpy(t_date+8,ovtmdate+6,2);
                    t_date[10] = '\0';
                  
               /*infra       sprintf(log_buff," 초과근무일자 : %s,  직급 : %s \n", t_date,paycl); */
                    sprintf(log_buff," 초과근무일자 : %s,  BAND : %s \n", t_date,paycl);                                
                                        WriteLog(log_buff);
               }
               s_count++;
          }
          else 
          {
               f_count++;
               sprintf(log_buff," 계산에 실패한 EMPNO : %s, KORNAME : %s \n ", empno,korname);
                                WriteLog(log_buff);
                                
               strncpy(t_date,ovtmdate,4);
               t_date[4] = '-';
               strncpy(t_date+5,ovtmdate+4,2);
               t_date[7] = '-';
               strncpy(t_date+8,ovtmdate+6,2);
               t_date[10] = '\0';
               
               /* printf(" 초과근무일자 : %s \n",t_date); */
               sprintf(log_buff," 초과근무일자 : %s \n",t_date);
               WriteLog(log_buff);
          }
     }
}
/*****************************************************************************
  대상자료를 추출하는 함수. - 이전
 *****************************************************************************/
process_records_N_old()
{
     char  t_date[11]   = "";
     char  maxcondate[8+1] = "";
     int   holicnt = 0;
     
     EXEC    SQL
     UPDATE  PKHOTHIS A
        SET  (PAYCL,PAYGR,PAYRA,ORGNUM,DEPTCODE )=
             (SELECT B.PAYCL,B.PAYGR,B.PAYRA,B.ORGNUM,B.DEPTCODE
                FROM   PKMPMAS B
               WHERE A.EMPNO = B.EMPNO
             )
      WHERE  OVTMDATE BETWEEN  :frworkdate AND :toworkdate
        AND  (A.EMPNO >= :frempno AND A.EMPNO <= :toempno )
        AND  UPPER(NVL(CONYN,' ')) = 'Y'
        AND  OTFLAG IS NULL
        AND  WRITETIME  = '***';
           
     if  ((sqlca.sqlcode != 1403) && (sqlca.sqlcode != 0)) 
     {
           sprintf(log_buff,"ERROR_CODE : %d, 인사자료 SETTING Error. \n", sqlca.sqlcode);
           WriteLog(log_buff);
     }
     

     EXEC SQL DECLARE cursor6 CURSOR FOR
     SELECT  NVL(OVTMDATE,' '), NVL(A.EMPNO,' '),
             NVL(A.KORNAME,' '),NVL(A.PAYCL,' '),
             NVL(FRAPPTIME,'*'), NVL(FRREALTIME,'*'),
             NVL(TOREALTIME,'*'), totpay,
             substr(NVL(CONLTIME,'00000000'),1,8),CONLEMP,
             NVL(RESTMM,0),NVL(SPRESTMM,0),NVL(TJOBDUTY, ' '),
             case when OVTMDATE < :comchdate                                     /*2017.01.01이후 초과근무수당 계산할 때 통상임금이 기준시간 226hr->209hr*/
                  then hper.COMMONUTIL.GET_OLDBASEPAY(a.EMPNO,c.YEARPAYNUM)
                  else hper.COMMONUTIL.GET_NEWBASEPAY(a.EMPNO,c.YEARPAYNUM) end  /*DB package에서 계산 jissi. 2016.12.14*/
       FROM  PKHOTHIS A, PKHYPHIS B, PKCPBAS C, PIMPMAS D
      WHERE  OVTMDATE BETWEEN :frworkdate AND :toworkdate 
        AND  A.EMPNO >= :frempno AND A.EMPNO <= :toempno 
        AND  TO_CHAR(C.YEARPAYNUM) =  B.YEARPAYNUM 
        AND  A.EMPNO = B.EMPNO 
        AND  B.EMPNO = D.EMPNO
        AND  OTFLAG IS NULL
        AND  UPPER(NVL(CONYN,' ')) = 'Y' 
        AND  A.WRITETIME = '***'
      ORDER  BY A.EMPNO, OVTMDATE;
     
     EXEC SQL OPEN cursor6;
     
     if ((sqlca.sqlcode != 1403) && (sqlca.sqlcode != 0) &&
         (sqlca.sqlcode != -1405)) 
     {
        
          sprintf(log_buff,"In the Select ERROR_CODE : %d, Cursor6 Open Error\n", sqlca.sqlcode);
          WriteLog(log_buff);
                   
          EXEC SQL CLOSE cursor6;
          return(FAIL);
     }
     
     while(1) 
     {
          EXEC SQL FETCH cursor6
          INTO :ovtmdate, :empno, :korname, :paycl, 
          	   :frapptime,:frrealtime, :torealtime, :totpay,
               :conltime, :conlemp,
               :t_restmm,:t_sprestmm ,:tjobduty, :tongpay;
          
          if  (sqlca.sqlcode == 1403) 
          {
               EXEC SQL CLOSE cursor6;
               return(SUCCESS);
          }
          
          trail_spaces(frapptime);
          trail_spaces(frrealtime);
          trail_spaces(torealtime);
          trail_spaces(paycl);
          
          
          sprintf(log_buff,"   ");
          WriteLog(log_buff);
          
          t_nighthh   = 0;
          t_genexthh  = 0;
          t_holihh    = 0;
          t_holiexthh = 0;
          t_mealhh    = 0;
          t_excephh   = 0;

                
          if ( (get_nighthh(frrealtime,torealtime)    == SUCCESS) &&
               (get_genexthh(frrealtime,torealtime)   == SUCCESS) &&
               (process_holihh(frrealtime,torealtime) == SUCCESS) &&
/* ==============================================================================
 Version  date(yy.mm.dd)  programmer  description                relevant doc.no  
 30.20    2001.08.09.      유효성       휴일근무시 식사시간 제외 추가 
============================================================================= */
               (get_mealhh(frrealtime, torealtime) == SUCCESS) &&
               (get_excepthh(frrealtime, torealtime)== SUCCESS) ) 
          
          {
               if  (update_record() != SUCCESS) 
               {
                    sprintf(log_buff," 수당 수정 불가자 =>사번 : %s, 성명 : %s \n ",  empno,korname);
                    WriteLog(log_buff);
                   
                    strncpy(t_date,ovtmdate,4);
                    t_date[4] = '-';
                    strncpy(t_date+5,ovtmdate+4,2);
                    t_date[7] = '-';
                    strncpy(t_date+8,ovtmdate+6,2);
                    t_date[10] = '\0';
                  
                    sprintf(log_buff," 초과근무일자 : %s,  BAND : %s \n", t_date,paycl);                                
                                        WriteLog(log_buff);
               }
               s_count++;
          }
          else 
          {
               f_count++;
               sprintf(log_buff," 계산에 실패한 EMPNO : %s, KORNAME : %s \n ", empno,korname);
                                WriteLog(log_buff);
                                
               strncpy(t_date,ovtmdate,4);
               t_date[4] = '-';
               strncpy(t_date+5,ovtmdate+4,2);
               t_date[7] = '-';
               strncpy(t_date+8,ovtmdate+6,2);
               t_date[10] = '\0';
               
               /* printf(" 초과근무일자 : %s \n",t_date); */
               sprintf(log_buff," 초과근무일자 : %s \n",t_date);
               WriteLog(log_buff);
          }
     }
}
/*****************************************************************************
  대상자료를 추출하는 함수.== 정규사원 이전
 *****************************************************************************/
process_records_old()
{
     char  t_date[11]   = "";

     EXEC SQL
     UPDATE  PKHOTHIS A
        SET (PAYCL,PAYGR,PAYRA,ORGNUM,DEPTCODE )=
          (SELECT B.PAYCL,B.PAYGR,B.PAYRA,B.ORGNUM,B.DEPTCODE
                 FROM   PKMPMAS B
                 WHERE A.EMPNO = B.EMPNO
          )
     WHERE  SUBSTR(OVTMDATE,1,6) = :workmm
       AND  (A.EMPNO >= :frempno AND A.EMPNO <= :toempno )
       AND  OTFLAG IS NULL
       AND  UPPER(NVL(CONYN,' ')) = 'Y';

     if ((sqlca.sqlcode != 1403) && (sqlca.sqlcode != 0))
     {
          printf("ERROR_CODE : %d, 인사자료 SETTING Error. \n", sqlca.sqlcode);
          sprintf(log_buff, "ERROR_CODE : %d, 인사자료 SETTING Error. \n", sqlca.sqlcode); /*dsa2000 Rexec 대체*/
          Write_batlog(seqno++, log_buff);
     }
     
     EXEC SQL DECLARE cursor5 CURSOR FOR
     SELECT
             NVL(OVTMDATE,' '), NVL(A.EMPNO,' '),
             NVL(A.KORNAME,' '),NVL(A.PAYCL,' '),
             NVL(FRAPPTIME,'*'), NVL(FRREALTIME,'*'),
             NVL(TOREALTIME,'*'), totpay,
             NVL(RESTMM,0),NVL(SPRESTMM,0)
       FROM  PKHOTHIS A, PKHYPHIS B
      WHERE  (SUBSTR(OVTMDATE,1,6) = :workmm)
        AND  (A.EMPNO >= :frempno AND A.EMPNO <= :toempno )
        AND  (B.YEARPAYNUM = :yearpaynum)
        AND  (A.EMPNO = B.EMPNO)
        AND  (UPPER(NVL(CONYN,' ')) = 'Y' )
        AND  OTFLAG IS NULL
        AND  PAYCL <='D41'      /*infra   PAYCL <='99' */
      ORDER  BY A.EMPNO, OVTMDATE;

     EXEC SQL OPEN cursor5;
     if ((sqlca.sqlcode != 1403) && (sqlca.sqlcode != 0) && (sqlca.sqlcode != -1405))
     {
          printf("ERROR_CODE : %d, Cursor5 Open Error\n",  sqlca.sqlcode);
          sprintf(log_buff, "ERROR_CODE : %d, Cursor5 Open Error. \n", sqlca.sqlcode); /*dsa2000 Rexec 대체*/
          Write_batlog(seqno++, log_buff);
          EXEC SQL CLOSE cursor5;
          return(FAIL);
     }

     while(1)
     {
          EXEC SQL FETCH cursor5
             INTO :ovtmdate, :empno, :korname, :paycl,
                  :frapptime,:frrealtime,
                  :torealtime, :totpay, :t_restmm,:t_sprestmm;
          if (sqlca.sqlcode == 1403) {
            EXEC SQL CLOSE cursor5;
            return(SUCCESS);
          }

          trail_spaces(frapptime);
          trail_spaces(frrealtime);
          trail_spaces(torealtime);
          trail_spaces(paycl);

          t_nighthh   = 0;
          t_genexthh  = 0;
          t_holihh    = 0;
          t_holiexthh = 0;
          t_mealhh    = 0;
          t_excephh   = 0;

          t_extmm     = 0;
          t_nightmm   = 0;
          t_holimm    = 0;
          t_genextmm  = 0;
          t_holiextmm = 0;
          t_mealmm    = 0;


          if ( (get_nighthh(frrealtime,torealtime)    == SUCCESS) &&
               (get_genexthh(frrealtime,torealtime)   == SUCCESS) &&
               (process_holihh(frrealtime,torealtime) == SUCCESS) &&
/* ==============================================================================
 Version  date(yy.mm.dd)  programmer  description                 relevant doc.no
 30.20    2001.08.09.      유효성       휴일근무시 식사시간 제외 추가
============================================================================= */
               (get_mealhh(frrealtime, torealtime) == SUCCESS) &&
               (get_excepthh(frrealtime, torealtime)== SUCCESS) )
          {
               if  (update_record() != SUCCESS)
               {
                    printf(" EMPNO : %s, KORNAME : %s \n ", empno,korname);
                    /*sprintf(log_buff, " EMPNO : %s, KORNAME : %s \n ", empno,korname); dsa2000 Rexec 대체*/
                              /*Write_batlog(seqno++, log_buff);*/
                    strncpy(t_date,ovtmdate,4);
                    t_date[4] = '-';
                    strncpy(t_date+5,ovtmdate+4,2);
                    t_date[7] = '-';
                    strncpy(t_date+8,ovtmdate+6,2);
                    t_date[10] = '\0';
                    printf(" 초과근무일자 : %s \n",t_date);
                    printf(" BAND : %s \n",paycl);
               }
               s_count++;
          }
          else
          {
               f_count++;
               printf(" 계산에 실패한 EMPNO : %s, KORNAME : %s \n ", empno,korname);
               /*sprintf(log_buff, " 계산에 실패한 EMPNO : %s, KORNAME : %s \n ", empno,korname); dsa2000 Rexec 대체*/
                        /*Write_batlog(seqno++, log_buff);*/
               strncpy(t_date,ovtmdate,4);
               t_date[4] = '-';
               strncpy(t_date+5,ovtmdate+4,2);
               t_date[7] = '-';
               strncpy(t_date+8,ovtmdate+6,2);
               t_date[10] = '\0';
               printf(" 초과근무일자 : %s \n",t_date);
          }
     }

}

/**********************************************************************************************
  야간근로시간을 실제근무시작시간과 실제근무종료시간으로 부터 구하는 함수. (총 10시간 이내범위)

  (야간근로시간 인정시간)
  당일 22:00 ~ 익일 06:00 (8시간)
  익일 22:00 ~ 익일 24:00 (2시간)
  => 초과근무 시작시간과 종료시간을 계산하여 실제 야간근로시간에 해당되는 시간을 산출.
***********************************************************************************************/
get_nighthh(char *frtime, char *totime)
{
     int    dd       = 0;
     int    tmp      = 0;
     char   stime[5] = "";
     char   etime[5] = "";
     char   t_str[5] = "";
     int    btime1   = 0;
     int    btime2   = 0;
     int    btime3   = 0;
     int    btime4   = 0;
     int    istime   = 0;
     int    ietime   = 0;

     strncpy(stime,frtime+8,4);
     strncpy(etime,totime+8,4);
     istime = atoi(stime);
     ietime = atoi(etime);
     btime1 = atoi(FRTIME1);
     btime2 = atoi(TOTIME1);
     btime3 = atoi(FRTIME2);
     btime4 = atoi(TOTIME2);


     dd = check_datetime(frtime,totime);
     if  (dd == FAIL)
          return(FAIL);

     if  (dd == 1)
     {
          strncpy(t_str,totime+8,4);

          tmp   = atoi(t_str);
          ietime  = tmp + 2400;
     }
     else if ((dd == 0) && (strcmp(stime,"0000") >= 0) &&
              (strcmp(stime,"0800") < 0))
     {
          strncpy(t_str,frtime+8,4);
          tmp   = atoi(t_str);
          istime   = tmp + 2400;

          strncpy(t_str,totime+8,4);
          tmp = atoi(t_str);
          ietime = tmp + 2400;
          //printf(" 초과근무일자 : %s,%s,%s,%s \n",tmp,istime,ietime);
     }

     if ((istime >= btime1) && (istime <= btime2) &&
         (ietime > btime2) )
     {
          t_nighthh = get_hourterm(istime,btime2);  /* 야간근무시간 인정시간 : 실제시작시간 ~ 익일06:00 */
          t_nightmm = get_minterm(istime,btime2);
     }
     else if ((ietime >= btime1) &&
              (ietime <= btime2) &&
              (istime < btime1))
     {
          t_nighthh = get_hourterm(btime1,ietime);  /* 야간근무시간 인정시간 : 22:00 ~ 실제종료시간  */
          t_nightmm = get_minterm(btime1,ietime);
     }
     else if ((istime >= btime1) && (istime <= btime2) &&
              (ietime <= btime2) && (ietime >  istime))
     {
          t_nighthh = get_hourterm(istime,ietime);
          t_nightmm = get_minterm(istime,ietime);
     }
     else if ((istime <= btime1) && (ietime >= btime2) &&
              (ietime >  istime))
     {
          t_nighthh = get_hourterm(btime1,btime2);  /* 야간근무시간 인정시간 : 22:00 ~ 익일06:00  */
          t_nightmm = get_minterm(btime1,btime2);
     }
     else
     {
          t_nighthh = 0;
     }

     if ((ietime >= btime3) && (ietime <= btime4)) {
          t_nighthh += get_hourterm(btime3,ietime); /* 야간근무시간 인정시간 : 익일 야간근무시간까지 합산(2시간이내) */
          t_nightmm += get_minterm(btime3,ietime);
     }

     return(SUCCESS);
}
/* ==============================================================================
 Version  date(yy.mm.dd)  programmer  description                 relevant doc.no
 30.20    2001.08.09.      유효성       휴일근무시 식사시간 제외 추가
============================================================================= */

/*****************************************************************************
  실제근무시작시간과 실제근무종료시간으로 부터 식사시간을 구하는 함수.== 정규직
******************************************************************************/
get_mealhh(char *frtime, char *totime)
{
     int    dd       =  0;
     int    tmp      =  0;
     char   stime[5] = "";
     char   etime[5] = "";
     char   t_str[5] = "";
     char   str[8+1] = "";
     int    btime1   =  0;
     int    btime2   =  0;
     int    istime   =  0;
     int    ietime   =  0;
     int    daykind  =  0;
     /* double t_mealmm =  0; */

     strncpy(stime,frtime+8,4);
     strncpy(etime,totime+8,4);
     istime = atoi(stime);
     ietime = atoi(etime);


     strncpy(str,frtime,8);
     daykind   = get_daykind(str);

     dd = check_datetime(frtime,totime);


     if  (dd == FAIL)
          return(FAIL);

     if ((daykind == 1)  && (dd == 0) ) /*평일이면서 초과근무시간이 당일 범위 이내이면 계산안함.*/
          return (SUCCESS) ;

     if  (dd == 1)
     {
          strncpy(t_str,totime+8,4);
          tmp   = atoi(t_str);
          ietime  = tmp + 2400;
     }


     /*
      아침 : 08:00 ~ 09:00
      점심 : 12:00 ~ 13:00
      저녁 : 18:00 ~ 19:00
     */
     /* 자율 책임 근무제 집계는 2018.08.01부터 가능 - 2018.06.29 Sangmoon Lee */
     /* 자율 책임 근무제 대상자("G","O") 식사시간제외 삭제 */
     /* 자율 책임 근무제 비대상자("N") 식사시간제외 적용 - 2018.08.17 Sangmoon Lee */
     if  ((strcmp(otflag, "N") == 0))
     {
          /* 아침, 점심, 저녁 식사시간을 차례로 계산 */
          if  (daykind == 4 )
          {
              /*아침*/
     
               btime1 = 800 ;
               btime2 = 900 ;
     
               if ((istime >= btime1) && (istime <= btime2) &&
                   (ietime > btime2) )
               {
                    t_mealmm  = get_minterm(istime, btime2) ;
               }
               else if ((ietime >= btime1) &&
                        (ietime <= btime2) &&
                        (istime < btime1))
               {
                    t_mealmm  = get_minterm(btime1,ietime);
               }
               else if ((istime >= btime1) && (istime <= btime2) &&
                        (ietime <= btime2) && (ietime >  istime))
               {
                    t_mealmm = get_minterm(istime,ietime);
               }
               else if ((istime <= btime1) && (ietime >= btime2) &&
                        (ietime >  istime))
               {
                    t_mealmm = get_minterm(btime1,btime2);
               }
               else
               {
                    t_mealmm = 0;
               }
     
               /*점심*/
     
               btime1 = 1200 ;
               btime2 = 1300 ;
     
               if ((istime >= btime1) && (istime <= btime2) &&
                   (ietime > btime2) )
               {
                    t_mealmm +=  get_minterm(istime,btime2);
               }
               else if ((ietime >= btime1) &&
                        (ietime <= btime2) &&
                        (istime < btime1))
               {
                    t_mealmm  += get_minterm(btime1,ietime);
               }
               else if ((istime >= btime1) && (istime <= btime2) &&
                        (ietime <= btime2) && (ietime >  istime))
               {
                    t_mealmm += get_minterm(istime,ietime);
               }
               else if ((istime <= btime1) && (ietime >= btime2) &&
                        (ietime >  istime))
               {
                    t_mealmm += get_minterm(btime1,btime2);
               }
               else
               {
                    t_mealmm += 0;
               }
          }
     
          /*저녁*/
     
          btime1 = 1800 ;
          btime2 = 1900 ;
     
     
          if ((istime >= btime1) && (istime <= btime2) &&
              (ietime > btime2) )
          {
               t_mealmm += get_minterm(istime,btime2);
          }
          else if ((ietime >= btime1) &&
                   (ietime <= btime2) &&
                   (istime < btime1))
          {
               t_mealmm += get_minterm(btime1,ietime);
          }
          else if ((istime >= btime1) && (istime <= btime2) &&
                   (ietime <= btime2) && (ietime >  istime))
          {
               t_mealmm += get_minterm(istime,ietime);
          }
          else if ((istime <= btime1) && (ietime >= btime2) &&
                   (ietime >  istime))
          {
               t_mealmm += get_minterm(btime1,btime2);
          }
          else
          {
               t_mealmm += 0;
          }
     
     
          if ((dd == 1) && (strcmp(etime,"0800") > 0))
          {
               /*다음날 아침*/
     
               btime1 = 800 + 2400 ;
               btime2 = 900 + 2400 ;
     
               if ((istime >= btime1) && (istime <= btime2) &&
                   (ietime > btime2) )    {
                    t_mealmm += get_minterm(istime, btime2) ;
               }
               else if ((ietime >= btime1) &&
                        (ietime <= btime2) &&
                        (istime < btime1))
               {
                    t_mealmm += get_minterm(btime1,ietime);
               }
               else if ((istime >= btime1) && (istime <= btime2) &&
                        (ietime <= btime2) && (ietime >  istime))
               {
                    t_mealmm += get_minterm(istime,ietime);
               }
               else if ((istime <= btime1) && (ietime >= btime2) &&
                        (ietime >  istime))
               {
                    t_mealmm += get_minterm(btime1,btime2);
               }
               else
               {
                    t_mealmm += 0;
               }
     
     
               /* 다음날 점심*/
     
               btime1 = 1200 + 2400 ;
               btime2 = 1300 + 2400 ;
     
               if ((istime >= btime1) && (istime <= btime2) &&
                   (ietime > btime2) )
               {
                    t_mealmm  +=  get_minterm(istime,btime2);
               }
               else if ((ietime >= btime1) &&
                        (ietime <= btime2) &&
                        (istime < btime1))
               {
                    t_mealmm  += get_minterm(btime1,ietime);
               }
               else if ((istime >= btime1) && (istime <= btime2) &&
                        (ietime <= btime2) && (ietime >  istime))
               {
                    t_mealmm += get_minterm(istime,ietime);
               }
               else if ((istime <= btime1) && (ietime >= btime2) &&
                        (ietime >  istime))
               {
                    t_mealmm += get_minterm(btime1,btime2);
               }
               else
               {
                    t_mealmm += 0;
               }
     
     
               /*다음날 저녁*/
     
               btime1 = 1800 + 2400;
               btime2 = 1900 + 2400;
     
     
               if ((istime >= btime1) && (istime <= btime2) &&
                   (ietime > btime2) )
               {
                    t_mealmm  += get_minterm(istime,btime2);
               }
               else if ((ietime >= btime1) &&
                        (ietime <= btime2) &&
                        (istime < btime1))
               {
                    t_mealmm += get_minterm(btime1,ietime);
               }
               else if ((istime >= btime1) && (istime <= btime2) &&
                        (ietime <= btime2) && (ietime >  istime))
               {
                    t_mealmm += get_minterm(istime,ietime);
               }
               else if ((istime <= btime1) && (ietime >= btime2) &&
                        (ietime >  istime))
               {
                    t_mealmm += get_minterm(btime1,btime2);
               }
               else
               {
                    t_mealmm += 0;
               }
          }
     }
     //if  (((strcmp(otflag, "O") == 0)) ||
     //     ((strcmp(sumYN,"Y") == 0) && (strcmp(curdate, SUMDATE) < 0)) ||
     //     ((strcmp(sumYN,"N") == 0) && (strcmp(curdate, CALDATE) < 0)))
     //{
     //     /* 아침, 점심, 저녁 식사시간을 차례로 계산 */
     //     if  (daykind == 4 )
     //     {
     //         /*아침*/
     //
     //          btime1 = 800 ;
     //          btime2 = 900 ;
     //
     //          if ((istime >= btime1) && (istime <= btime2) &&
     //              (ietime > btime2) )
     //          {
     //               t_mealmm  = get_minterm(istime, btime2) ;
     //          }
     //          else if ((ietime >= btime1) &&
     //                   (ietime <= btime2) &&
     //                   (istime < btime1))
     //          {
     //               t_mealmm  = get_minterm(btime1,ietime);
     //          }
     //          else if ((istime >= btime1) && (istime <= btime2) &&
     //                   (ietime <= btime2) && (ietime >  istime))
     //          {
     //               t_mealmm = get_minterm(istime,ietime);
     //          }
     //          else if ((istime <= btime1) && (ietime >= btime2) &&
     //                   (ietime >  istime))
     //          {
     //               t_mealmm = get_minterm(btime1,btime2);
     //          }
     //          else
     //          {
     //               t_mealmm = 0;
     //          }
     //
     //          /*점심*/
     //
     //          btime1 = 1200 ;
     //          btime2 = 1300 ;
     //
     //          if ((istime >= btime1) && (istime <= btime2) &&
     //              (ietime > btime2) )
     //          {
     //               t_mealmm +=  get_minterm(istime,btime2);
     //          }
     //          else if ((ietime >= btime1) &&
     //                   (ietime <= btime2) &&
     //                   (istime < btime1))
     //          {
     //               t_mealmm  += get_minterm(btime1,ietime);
     //          }
     //          else if ((istime >= btime1) && (istime <= btime2) &&
     //                   (ietime <= btime2) && (ietime >  istime))
     //          {
     //               t_mealmm += get_minterm(istime,ietime);
     //          }
     //          else if ((istime <= btime1) && (ietime >= btime2) &&
     //                   (ietime >  istime))
     //          {
     //               t_mealmm += get_minterm(btime1,btime2);
     //          }
     //          else
     //          {
     //               t_mealmm += 0;
     //          }
     //     }
     //
     //     /*저녁*/
     //
     //     btime1 = 1800 ;
     //     btime2 = 1900 ;
     //
     //
     //     if ((istime >= btime1) && (istime <= btime2) &&
     //         (ietime > btime2) )
     //     {
     //          t_mealmm += get_minterm(istime,btime2);
     //     }
     //     else if ((ietime >= btime1) &&
     //              (ietime <= btime2) &&
     //              (istime < btime1))
     //     {
     //          t_mealmm += get_minterm(btime1,ietime);
     //     }
     //     else if ((istime >= btime1) && (istime <= btime2) &&
     //              (ietime <= btime2) && (ietime >  istime))
     //     {
     //          t_mealmm += get_minterm(istime,ietime);
     //     }
     //     else if ((istime <= btime1) && (ietime >= btime2) &&
     //              (ietime >  istime))
     //     {
     //          t_mealmm += get_minterm(btime1,btime2);
     //     }
     //     else
     //     {
     //          t_mealmm += 0;
     //     }
     //
     //
     //     if ((dd == 1) && (strcmp(etime,"0800") > 0))
     //     {
     //          /*다음날 아침*/
     //
     //          btime1 = 800 + 2400 ;
     //          btime2 = 900 + 2400 ;
     //
     //          if ((istime >= btime1) && (istime <= btime2) &&
     //              (ietime > btime2) )    {
     //               t_mealmm += get_minterm(istime, btime2) ;
     //          }
     //          else if ((ietime >= btime1) &&
     //                   (ietime <= btime2) &&
     //                   (istime < btime1))
     //          {
     //               t_mealmm += get_minterm(btime1,ietime);
     //          }
     //          else if ((istime >= btime1) && (istime <= btime2) &&
     //                   (ietime <= btime2) && (ietime >  istime))
     //          {
     //               t_mealmm += get_minterm(istime,ietime);
     //          }
     //          else if ((istime <= btime1) && (ietime >= btime2) &&
     //                   (ietime >  istime))
     //          {
     //               t_mealmm += get_minterm(btime1,btime2);
     //          }
     //          else
     //          {
     //               t_mealmm += 0;
     //          }
     //
     //
     //          /* 다음날 점심*/
     //
     //          btime1 = 1200 + 2400 ;
     //          btime2 = 1300 + 2400 ;
     //
     //          if ((istime >= btime1) && (istime <= btime2) &&
     //              (ietime > btime2) )
     //          {
     //               t_mealmm  +=  get_minterm(istime,btime2);
     //          }
     //          else if ((ietime >= btime1) &&
     //                   (ietime <= btime2) &&
     //                   (istime < btime1))
     //          {
     //               t_mealmm  += get_minterm(btime1,ietime);
     //          }
     //          else if ((istime >= btime1) && (istime <= btime2) &&
     //                   (ietime <= btime2) && (ietime >  istime))
     //          {
     //               t_mealmm += get_minterm(istime,ietime);
     //          }
     //          else if ((istime <= btime1) && (ietime >= btime2) &&
     //                   (ietime >  istime))
     //          {
     //               t_mealmm += get_minterm(btime1,btime2);
     //          }
     //          else
     //          {
     //               t_mealmm += 0;
     //          }
     //
     //
     //          /*다음날 저녁*/
     //
     //          btime1 = 1800 + 2400;
     //          btime2 = 1900 + 2400;
     //
     //
     //          if ((istime >= btime1) && (istime <= btime2) &&
     //              (ietime > btime2) )
     //          {
     //               t_mealmm  += get_minterm(istime,btime2);
     //          }
     //          else if ((ietime >= btime1) &&
     //                   (ietime <= btime2) &&
     //                   (istime < btime1))
     //          {
     //               t_mealmm += get_minterm(btime1,ietime);
     //          }
     //          else if ((istime >= btime1) && (istime <= btime2) &&
     //                   (ietime <= btime2) && (ietime >  istime))
     //          {
     //               t_mealmm += get_minterm(istime,ietime);
     //          }
     //          else if ((istime <= btime1) && (ietime >= btime2) &&
     //                   (ietime >  istime))
     //          {
     //               t_mealmm += get_minterm(btime1,btime2);
     //          }
     //          else
     //          {
     //               t_mealmm += 0;
     //          }
     //     }
     //}
     ///* Sangmoon Lee 2018.06.19 - 휴일근로를 하게 되면 휴일 가산수당이 붙지만 점심과 저녁 각각 1시간씩을 제외 박명언M */
     //else if  (strcmp(otflag, "G") == 0)
     //{
     //     /* 점심, 저녁 식사시간을 차례로 계산 */
     //     if  (daykind == 4 )
     //     {
     //          /*점심*/
     //
     //          btime1 = 1200 ;
     //          btime2 = 1300 ;
     //
     //          if ((istime >= btime1) && (istime <= btime2) &&
     //              (ietime > btime2) )
     //          {
     //               t_mealmm =  get_minterm(istime,btime2);
     //          }
     //          else if ((ietime >= btime1) &&
     //                   (ietime <= btime2) &&
     //                   (istime < btime1))
     //          {
     //               t_mealmm  = get_minterm(btime1,ietime);
     //          }
     //          else if ((istime >= btime1) && (istime <= btime2) &&
     //                   (ietime <= btime2) && (ietime >  istime))
     //          {
     //               t_mealmm = get_minterm(istime,ietime);
     //          }
     //          else if ((istime <= btime1) && (ietime >= btime2) &&
     //                   (ietime >  istime))
     //          {
     //               t_mealmm = get_minterm(btime1,btime2);
     //          }
     //          else
     //          {
     //               t_mealmm = 0;
     //          }
     //
     //          /*저녁*/
     //
     //          btime1 = 1800 ;
     //          btime2 = 1900 ;
     //
     //
     //          if ((istime >= btime1) && (istime <= btime2) &&
     //              (ietime > btime2) )
     //          {
     //               t_mealmm += get_minterm(istime,btime2);
     //          }
     //          else if ((ietime >= btime1) &&
     //                   (ietime <= btime2) &&
     //                   (istime < btime1))
     //          {
     //               t_mealmm += get_minterm(btime1,ietime);
     //          }
     //          else if ((istime >= btime1) && (istime <= btime2) &&
     //                   (ietime <= btime2) && (ietime >  istime))
     //          {
     //               t_mealmm += get_minterm(istime,ietime);
     //          }
     //          else if ((istime <= btime1) && (ietime >= btime2) &&
     //                   (ietime >  istime))
     //          {
     //               t_mealmm += get_minterm(btime1,btime2);
     //          }
     //          else
     //          {
     //               t_mealmm += 0;
     //          }
     //     }
     //}
     t_mealhh = floor(t_mealmm / 60) ;

     return(SUCCESS);
}

/* 계약직 식사시간 기준 변경으로 식사시간 로직 정규직, 계약직 분리 - 2018.02.08 SangMoon Lee */
/* 계약직은 조식시간 제외 되도록... - HR팀 김선일M [SR-1802-0251] */

/*****************************************************************************
  실제근무시작시간과 실제근무종료시간으로 부터 식사시간을 구하는 함수.== 계약직
******************************************************************************/
get_mealhh_con(char *frtime, char *totime)
{
     int    dd       =  0;
     int    tmp      =  0;
     char   stime[5] = "";
     char   etime[5] = "";
     char   t_str[5] = "";
     char   str[8+1] = "";
     int    btime1   =  0;
     int    btime2   =  0;
     int    istime   =  0;
     int    ietime   =  0;
     int    daykind  =  0;
     /* double t_mealmm =  0; */

     strncpy(stime,frtime+8,4);
     strncpy(etime,totime+8,4);
     istime = atoi(stime);
     ietime = atoi(etime);


     strncpy(str,frtime,8);
     daykind   = get_daykind(str);

     dd = check_datetime(frtime,totime);


     if  (dd == FAIL)
          return(FAIL);

     if ((daykind == 1)  && (dd == 0) ) /*평일이면서 초과근무시간이 당일 범위 이내이면 계산안함.*/
          return (SUCCESS) ;

     if  (dd == 1)
     {
          strncpy(t_str,totime+8,4);
          tmp   = atoi(t_str);
          ietime  = tmp + 2400;
     }

     /* 자율 책임 근무제 대상자("G","O") 식사시간제외 삭제 */
     /* 자율 책임 근무제 비대상자("N") 식사시간제외 적용 - 2018.08.17 Sangmoon Lee */
     if  ((strcmp(otflag, "N") == 0))
     {
          /* 아침, 점심, 저녁 식사시간을 차례로 계산 */
          if  (daykind == 4 )
          {
          /*아침 제외*/
          
          /*점심*/
               btime1 = 1200 ;
               btime2 = 1300 ;
          
               if ((istime >= btime1) && (istime <= btime2) &&
                   (ietime > btime2) )
               {
                    t_mealmm =  get_minterm(istime,btime2);
               }
               else if ((ietime >= btime1) &&
                        (ietime <= btime2) &&
                        (istime < btime1))
               {
                    t_mealmm  = get_minterm(btime1,ietime);
               }
               else if ((istime >= btime1) && (istime <= btime2) &&
                        (ietime <= btime2) && (ietime >  istime))
               {
                    t_mealmm = get_minterm(istime,ietime);
               }
               else if ((istime <= btime1) && (ietime >= btime2) &&
                        (ietime >  istime))
               {
                    t_mealmm = get_minterm(btime1,btime2);
               }
               else
               {
                    t_mealmm = 0;
               }
          }
          
          /*저녁*/
          /* 석식시간은 동절기, 하절기에 따른 구분값 적용하여 계산 */
          btime1 = 1800 ;
          btime2 = 1900 ;
          
          
          if ((istime >= btime1) && (istime <= btime2) &&
              (ietime > btime2) )
          {
               t_mealmm += get_minterm(istime,btime2);
          }
          else if ((ietime >= btime1) &&
                   (ietime <= btime2) &&
                   (istime < btime1))
          {
               t_mealmm += get_minterm(btime1,ietime);
          }
          else if ((istime >= btime1) && (istime <= btime2) &&
                   (ietime <= btime2) && (ietime >  istime))
          {
               t_mealmm += get_minterm(istime,ietime);
          }
          else if ((istime <= btime1) && (ietime >= btime2) &&
                   (ietime >  istime))
          {
               t_mealmm += get_minterm(btime1,btime2);
          }
          else
          {
               t_mealmm += 0;
          }
          
          
          /*다음날 아침*/
          
          if ((dd == 1) && (strcmp(etime,"0800") > 0))
          {
               btime1 = 800 + 2400 ;
               btime2 = 900 + 2400 ;
          
               if ((istime >= btime1) && (istime <= btime2) &&
                   (ietime > btime2) )    {
                    t_mealmm += get_minterm(istime, btime2) ;
               }
               else if ((ietime >= btime1) &&
                        (ietime <= btime2) &&
                        (istime < btime1))
               {
                    t_mealmm += get_minterm(btime1,ietime);
               }
               else if ((istime >= btime1) && (istime <= btime2) &&
                        (ietime <= btime2) && (ietime >  istime))
               {
                    t_mealmm += get_minterm(istime,ietime);
               }
               else if ((istime <= btime1) && (ietime >= btime2) &&
                        (ietime >  istime))
               {
                    t_mealmm += get_minterm(btime1,btime2);
               }
               else
               {
                    t_mealmm += 0;
               }
          
          
          /* 다음날 점심*/
          
               btime1 = 1200 + 2400 ;
               btime2 = 1300 + 2400 ;
          
               if ((istime >= btime1) && (istime <= btime2) &&
                   (ietime > btime2) )
               {
                    t_mealmm  +=  get_minterm(istime,btime2);
               }
               else if ((ietime >= btime1) &&
                        (ietime <= btime2) &&
                        (istime < btime1))
               {
                    t_mealmm  += get_minterm(btime1,ietime);
               }
               else if ((istime >= btime1) && (istime <= btime2) &&
                        (ietime <= btime2) && (ietime >  istime))
               {
                    t_mealmm += get_minterm(istime,ietime);
               }
               else if ((istime <= btime1) && (ietime >= btime2) &&
                        (ietime >  istime))
               {
                    t_mealmm += get_minterm(btime1,btime2);
               }
               else
               {
                    t_mealmm += 0;
               }
          
          
          /*다음날 저녁*/
          
               btime1 = 1800 + 2400;
               btime2 = 1900 + 2400;
          
          
               if ((istime >= btime1) && (istime <= btime2) &&
                   (ietime > btime2) )
               {
                    t_mealmm  += get_minterm(istime,btime2);
               }
               else if ((ietime >= btime1) &&
                        (ietime <= btime2) &&
                        (istime < btime1))
               {
                    t_mealmm += get_minterm(btime1,ietime);
               }
               else if ((istime >= btime1) && (istime <= btime2) &&
                        (ietime <= btime2) && (ietime >  istime))
               {
                    t_mealmm += get_minterm(istime,ietime);
               }
               else if ((istime <= btime1) && (ietime >= btime2) &&
                        (ietime >  istime))
               {
                    t_mealmm += get_minterm(btime1,btime2);
               }
               else
               {
                    t_mealmm += 0;
               }
          }
     }
     t_mealhh = floor(t_mealmm / 60) ;

     return(SUCCESS);
}

/****************************************************************************
       19:00(18:00)~08:00 9시간이상근무시 1시간 제외하는 함수
 ****************************************************************************/
get_excepthh(char *frtime, char* totime)
{
     char ba[20];
     char bb[20];
     int term = 0 ;
     int tmp = 0 ;

     char str[8+1] ="";

     int dd;
     sprintf(ba,"%s",frtime+8);
     sprintf(bb,"%s",totime+8);

     dd = check_datetime(frtime,totime);

     if  (dd == 0)
          return(SUCCESS);

     if  (dd == 1)
     {
          /* 자율 근무제 로직 반영 - Sangmoon Lee 2018.06.19 */
          /* 자율 책임 근무제 대상자("G","O") 9이상제외 삭제 */
          /* 자율 책임 근무제 비대상자("N") 9이상제외 적용 - 2018.08.17 Sangmoon Lee */
          if  ((strcmp(otflag, "N") == 0))
          {
               if  (strcmp(ba, "1900") < 0 )
                    strcpy(ba, "1900")  ;
          
               if  (strcmp(bb, "0800") > 0 )
                    strcpy(bb, "0800")  ;
          
               tmp = atoi(bb) + 2400 ;
          
               tmp = (int)(get_minterm(atoi(ba), tmp) / 60)  ;
          
               /*2014.05.20.hjku. 휴식초과가 한시간 미만일 경우 9시간 근무한 대상자에 대해 제외시간 처리.. 홍원영M */
               if  (( tmp >= 9 ) &&(floor(t_restmm/60)<1))
                     t_excephh = 1 ;
          }
          //if  (((strcmp(otflag, "O") == 0)) ||
          //     ((strcmp(sumYN,"Y") == 0) && (strcmp(curdate, SUMDATE) < 0)) ||
          //     ((strcmp(sumYN,"N") == 0) && (strcmp(curdate, CALDATE) < 0)))
          //{
          //     if  (strcmp(ba, "1900") < 0 )
          //          strcpy(ba, "1900")  ;
          //
          //     if  (strcmp(bb, "0800") > 0 )
          //          strcpy(bb, "0800")  ;
          //
          //     tmp = atoi(bb) + 2400 ;
          //
          //     tmp = (int)(get_minterm(atoi(ba), tmp) / 60)  ;
          //
          //     /*2014.05.20.hjku. 휴식초과가 한시간 미만일 경우 9시간 근무한 대상자에 대해 제외시간 처리.. 홍원영M */
          //     if  (( tmp >= 9 ) &&(floor(t_restmm/60)<1))
          //           t_excephh = 1 ;
          //}
          ///* Sangmoon Lee 2018.06.19 - 초과근무로 넘어가지 않은 상태에서 야간근로를 하게 되면 9시간 근무 시 제외시간(1시간) 처리.. 박명언M */
          //else if  (strcmp(otflag, "G") == 0)
          //{
          //     if  (strcmp(ba, "2200") < 0 )
          //          strcpy(ba, "2200")  ;
          //
          //     if  (strcmp(bb, "0800") > 0 )
          //          strcpy(bb, "0800")  ;
          //
          //     tmp = atoi(bb) + 2400 ;
          //
          //     tmp = (int)(get_minterm(atoi(ba), tmp) / 60)  ;
          //
          //     if  (( tmp >= 9 ) &&(floor(t_restmm/60)<1))
          //           t_excephh = 1 ;
          //}
     }

     return (SUCCESS) ;
}

/****************************************************************************
        E1,H1평일 오전 시작시간과 종료시간 사이의 간격을 시간단위로 구하는 함수.
 ****************************************************************************/
float get_hourterm_con(int a,int b)
{
     int   mm1,mm2;
     int   hh1,hh2;
     float result;
     int   hh, qq;

     hh1 = (int) (a/100);
     hh2 = (int) (b/100);
     mm1 = a - (hh1*100);
     mm2 = b - (hh2*100);

     mm1 = hh1 * 60 + mm1;
     mm2 = hh2 * 60 + mm2;

     mm2 = mm2 - mm1;

     /*근무시간 오등록으로 음수가 나올 경우 check 2015.10.13 jissi*/
     if  (mm2 < 0)
          mm2 = 0;

     hh = ((int)mm2/60);
     qq = ((int)(mm2 -hh*60)/15);

     result = hh + 0.25 * qq; /* 15분 단위로 계산 */

     return(result);
}


/****************************************************************************
        시작시간과 종료시간 사이의 간격을 시간단위로 구하는 함수.
 ****************************************************************************/
get_hourterm(int a,int b)
{
     int mm1,mm2;
     int hh1,hh2;

     hh1 = (int) (a/100);
     hh2 = (int) (b/100);
     mm1 = a - (hh1*100);
     mm2 = b - (hh2*100);

     mm1 = hh1 * 60 + mm1;
     mm2 = hh2 * 60 + mm2;
     mm2 = mm2 - mm1;

     /*근무시간 오등록으로 음수가 나올 경우 check 2015.10.13 jissi*/
     if  (mm2 < 0)
          mm2 = 0;

     return((int)(mm2/60));
}

/****************************************************************************
        시작시간과 종료시간 사이의 간격을 분단위로 구하는 함수.
 ****************************************************************************/
get_minterm(int a,int b)
{
     int mm1,mm2;
     int hh1,hh2;

     hh1 = (int) (a/100);
     hh2 = (int) (b/100);
     mm1 = a - (hh1*100);
     mm2 = b - (hh2*100);

     mm1 = hh1 * 60 + mm1;
     mm2 = hh2 * 60 + mm2;
     mm2 = mm2 - mm1;
     return(mm2);
}

float get_ovtmhh(char *a, char* b)
{
     char  ba[20];
     char  bb[20];
     int   daykind1  = 0;
     int   daykind2  = 0;
     char  str[8+1]  = "";
     int   i,j,dd;
     int   tmp       = 0;

     sprintf(ba,"%s",a+8,4);
     sprintf(bb,"%s",b+8,4);
     i = atoi(ba);
     j = atoi(bb);

     strncpy(str,a,8);
     daykind1 = get_daykind(str);

     strncpy(str,b,8);
     daykind2 = get_daykind(str);

     dd = check_datetime(a,b);

     if  ((strcmp(sumYN,"Y") == 0) && (strcmp(curdate, SUMDATE) < 0))
     {
          //if ((strcmp(paycl,"E1") == 0 )||(strcmp(paycl,"H1") == 0 ))E1,H1 을 담당직무 비서 09,기사 15로 변경함. KTH
          if ((strcmp(tjobduty,"09") == 0 )||(strcmp(tjobduty,"15") == 0 ))
          {
               if  ((dd == 1)&&(daykind1!=4))
               {
                    j  = j + 2400;
          
                    if ((strcmp(bb,"0600") > 0)&&(strcmp(bb,"0830") <= 0)&&(daykind2!=4))
                    {
                         /*return(get_hourterm_con(i,j));
                           평일 근무시작시간을 정규근무시간내 등록한 경우 check 2015.10.13 jissi*/
                         if ((strcmp(ba,"0900") >= 0) && (strcmp(ba,"1800") <= 0))
                              return(get_hourterm_con(atoi("1800"),j));
                         else
                              return(get_hourterm_con(i,j));
                    }
                    else
                    {
                         /*return(get_hourterm(i,j));
                           평일 근무시작시간을 정규근무시간내 등록한 경우 check 2015.10.13 jissi*/
                         if ((strcmp(ba,"0900") >= 0) && (strcmp(ba,"1800") <= 0))
                              return(get_hourterm(atoi("1800"),j));
                         else
                              return(get_hourterm(i,j));
                    }
               }
               else if  ((dd == 1)&&(daykind1==4))
               {
                    j  = j + 2400;
          
                    if ((strcmp(bb,"0600") > 0)&&(strcmp(bb,"0830") <= 0)&&(daykind2!=4)) {
                         return(get_hourterm_con(i,j));
                    }
                    else
                    {
                         return(get_hourterm(i,j));
                    }
               }
               else if ((dd==0)&&(daykind1!=4))
               {
                    if(((strcmp(ba,"0600") > 0)&&(strcmp(ba,"0830") <  0))||
                       ((strcmp(bb,"0600") > 0)&&(strcmp(bb,"0830")<= 0)))
                    {
                         /*return(get_hourterm_con(i,j));
                           평일 근무시작시간을 정규근무시간내 등록한 경우 check 2015.10.13 jissi*/
                         if ((strcmp(ba,"0900") >= 0) && (strcmp(ba,"1800") <= 0))
                              return(get_hourterm_con(atoi("1800"),j));
                         else
                              return(get_hourterm_con(i,j));
                    }
                    else
                    {
                         /*return(get_hourterm(i,j));
                           평일 근무시작시간을 정규근무시간내 등록한 경우 check 2015.10.13 jissi*/
                         if ((strcmp(ba,"0900") >= 0) && (strcmp(ba,"1800") <= 0))
                              return(get_hourterm(atoi("1800"),j));
                         else
                              return(get_hourterm(i,j));
                    }
               }
               else
               {
                    return(get_hourterm(i,j));
               }
          }
          else
          {
               if (daykind1!=4)
               {
                    if  (dd == 0)
                    {
                         /*return(get_hourterm(i,j));
                         평일 근무시작시간을 정규근무시간내 등록한 경우 check 2015.10.13 jissi*/
                         if ((strcmp(ba,"0900") >= 0) && (strcmp(ba,"1800") <= 0))
                              return(get_hourterm(atoi("1800"),j));
                         else
                              return(get_hourterm(i,j));
                    }
                    else if (dd == 1)
                    {
                         j = j + 2400;
          
                         /*return(get_hourterm(i,j));
                         평일 근무시작시간을 정규근무시간내 등록한 경우 check 2015.10.13 jissi*/
                         if ((strcmp(ba,"0900") >= 0) && (strcmp(ba,"1800") <= 0))
                              return(get_hourterm(atoi("1800"),j));
                         else
                              return(get_hourterm(i,j));
                    }
                    else
                         return(0);
               }
               else
               {
                    if  (dd == 0)
                         return(get_hourterm(i,j));
                    else if (dd == 1)
                    {
                         j = j + 2400;
                         return(get_hourterm(i,j));
                    }
                    else
                         return(0);
               }
          }
     }
     else
     {
          if  (dd == 0)
               return(get_hourterm(i,j));
          else if (dd == 1)
          {
               j = j + 2400;
               return(get_hourterm(i,j));
          }
          else
               return(0);
     }
}



/****************************************************************************
  실제근무시간의 유효성을 Check 하는 함수.
****************************************************************************/
check_datetime(char *frtime,char *totime)
{
     int len       = 0;
     int  dd;
     char t_yy[3]  = "";
     char t_mm[3]  = "";
     char t_dd[3]  = "";
     char frstr[9] = "";
     char tostr[9] = "";

     len = strlen(frtime);
     if  (len != 12)
     {
          printf("실제시작시간값이 유효하지 않습니다.\n");
          sprintf(log_buff, "실제시작시간값이 유효하지 않습니다.\n"); /*dsa2000 Rexec 대체*/
          Write_batlog(seqno++, log_buff);
          return(FAIL);
     }

     len  = strlen(totime);
     if  (len != 12)
     {
          printf("실제종료시간값이 유효하지 않습니다.\n");
          sprintf(log_buff, "실제종료시간값이 유효하지 않습니다.\n"); /*dsa2000 Rexec 대체*/
          Write_batlog(seqno++, log_buff);
          return(FAIL);
     }

     strncpy(frstr,frtime,8);
     strncpy(tostr,totime,8);
     dd = calc_term(frstr,tostr);
     if  (dd == FAIL)
          return(FAIL);

     if ((dd < 0) || (dd >= 2))
     {
          printf("시작일과 종료일의 간격이 유효하지 않습니다.\n");
          sprintf(log_buff, "시작일과 종료일의 간격이 유효하지 않습니다.\n"); /*dsa2000 Rexec 대체*/
          Write_batlog(seqno++, log_buff);
          return(FAIL);
     }

     return(dd);
}

/***************************************************************************
  계약직 일반연장시간을 처리하는 함수.(2008.05.08 추가)
****************************************************************************/
get_genexthh_con(char *frtime,char *totime)
{
     int   tmp       = 0;
     int   dd        = 0;
     int   daykind1  = 0;
     int   daykind2  = 0;
     char  stime[5]  = "";
     char  etime[5]  = "";
     char  str[8+1]  = "";
     int   term      = 0;

     dd = check_datetime(frtime,totime);

     if (dd == FAIL) return(FAIL);

     strncpy(stime,frtime+8,4);
     strncpy(etime,totime+8,4);


     strncpy(str,frtime,8);
     daykind1 = get_daykind(str);

     strncpy(str,totime,8);
     daykind2 = get_daykind(str);

     /*printf("\nDEBUG frdate[%s],todate[%s], dakind1[%d],daykind2[%d],dd[%d]",frtime,totime,daykind1,daykind2,dd);*/

     /* 2008.05.08. 추가 E1,H1 평일 오전 0600~0830 사이 초과 근무수당 15분분단위로 초과근무 계산 (인력팀 정정명씨,신영섭대리 통해서.)*/
     /*printf("\nDEBUG dd[%d], dakind1[%d],daykind2[%d]/n",dd,daykind1,daykind2);
     담당직무 비서 09,기사 15로 변경함. KTH */
     
     /* 자율 책임 근무제 비대상자("N") 기존로직 적용 - 2018.08.17 Sangmoon Lee */
     if ( (strcmp(otflag,"N") == 0) ||
          ((strcmp(otflag," ") == 0) &&
           (((strcmp(sumYN,"Y") == 0) && (strcmp(curdate, SUMDATE) < 0)) ||
            ((strcmp(sumYN,"N") == 0) && (strcmp(curdate, CALDATE) < 0)) )) )
     {
          //if((strcmp(paycl,"E1") == 0 )||(strcmp(paycl,"H1") == 0 ))
          if ((strcmp(tjobduty,"09") == 0 )||(strcmp(tjobduty,"15") == 0 ))
          {
               if  (daykind1 != 4)
               {
                   if ((dd == 1)&&(daykind2 != 4))
                   {/* 예->200805050900~200805060830,또는 200805061900~200805070830 입력시 */
                        if ((strcmp(etime,"0600") > 0)&&(strcmp(etime,"0830") <= 0))
                        {
                             tmp   = atoi(etime);
                             tmp   = tmp + 2400;
          
                             /*t_genexthh = get_hourterm_con(atoi(stime),tmp);
                               평일 근무시작시간을 정규근무시간내 등록한 경우 check 2015.10.13 jissi*/
                             if ((strcmp(stime,"0900") >= 0) && (strcmp(stime,"1800") <= 0))
                             {
                                  t_genexthh = get_hourterm_con(atoi("1800"),tmp);
                                  t_genextmm = get_minterm(atoi("1800"),tmp);
                             }
                             else
                             {
                                  t_genexthh = get_hourterm_con(atoi(stime),tmp);
                                  t_genextmm = get_minterm(atoi(stime),tmp);
                             }
                        }
                        else
                        {
                             tmp   = atoi(etime);
                             tmp   = tmp + 2400;
          
                             /*t_genexthh = get_hourterm(atoi(stime),tmp);
                               평일 근무시작시간을 정규근무시간내 등록한 경우 check 2015.10.13 jissi*/
                             if ((strcmp(stime,"0900") >= 0) && (strcmp(stime,"1800") <= 0))
                             {
                                  t_genexthh = get_hourterm(atoi("1800"),tmp);
                                  t_genextmm = get_minterm(atoi("1800"),tmp);
                             }
                             else
                             {
                                  t_genexthh = get_hourterm(atoi(stime),tmp);
                                  t_genextmm = get_minterm(atoi(stime),tmp);
                             }
                        }
          
                        return(SUCCESS);
                   }
                   else if (dd == 0)
                   {
                        if(((strcmp(stime,"0600") > 0)&&(strcmp(stime,"0830") <= 0))||
                           ((strcmp(etime,"0600") > 0)&&(strcmp(etime,"0830") <= 0)))
                        {
                             /*t_genexthh = get_hourterm_con(atoi(stime),atoi(etime));
                               평일 근무시작시간을 정규근무시간내 등록한 경우 check 2015.10.13 jissi*/
                             if ((strcmp(stime,"0900") >= 0) && (strcmp(stime,"1800") <= 0))
                             {
                                  t_genexthh = get_hourterm_con(atoi("1800"),atoi(etime));
                                  t_genextmm = get_minterm(atoi("1800"),atoi(etime));
                             }
                             else
                             {
                                  t_genexthh = get_hourterm_con(atoi(stime),atoi(etime));
                                  t_genextmm = get_minterm(atoi(stime),atoi(etime));
                             }
                        }
                        else
                        {
                             /*t_genexthh = get_hourterm(atoi(stime),atoi(etime));
                               평일 근무시작시간을 정규근무시간내 등록한 경우 check 2015.10.13 jissi*/
                             if ((strcmp(stime,"0900") >= 0) && (strcmp(stime,"1800") <= 0))
                             {
                                  t_genexthh = get_hourterm(atoi("1800"),atoi(etime));
                                  t_genextmm = get_minterm(atoi("1800"),atoi(etime));
                             }
                             else
                             {
                                  t_genexthh = get_hourterm(atoi(stime),atoi(etime));
                                  t_genextmm = get_minterm(atoi(stime),atoi(etime));
                             }
                        }
          
                        return(SUCCESS);
                   }
                   else if ((dd == 1)&&(daykind2 == 4))  // 날짜가 2일이면서 첫날이 휴일이 경우 일반연장 넣어줌.  kth.
                   {
                        tmp     = atoi(etime);
                        tmp     = tmp + 2400;
          
                        /*t_genexthh = get_hourterm(atoi(stime),tmp);
                          평일 근무시작시간을 정규근무시간내 등록한 경우 check 2015.10.13 jissi*/
                        if ((strcmp(stime,"0900") >= 0) && (strcmp(stime,"1800") <= 0))
                        {
                             t_genexthh = get_hourterm(atoi("1800"),tmp);
                             t_genextmm = get_minterm(atoi("1800"),tmp);
                        }
                        else
                        {
                             t_genexthh = get_hourterm(atoi(stime),tmp);
                             t_genextmm = get_minterm(atoi(stime),tmp);
                        }
          
                        return(SUCCESS);
                   }
               }
               else
               {
                    t_genexthh = 0;
                    return(SUCCESS);
               }
          }
     }
     else if (strcmp(otflag,"O") == 0) /* 초과근무시 계산 */
     {
          //if((strcmp(paycl,"E1") == 0 )||(strcmp(paycl,"H1") == 0 ))
          if ((strcmp(tjobduty,"09") == 0 )||(strcmp(tjobduty,"15") == 0 ))
          {
               if  (daykind1 != 4)
               {
                   if ((dd == 1)&&(daykind2 != 4))
                   {/* 예->200805050900~200805060830,또는 200805061900~200805070830 입력시 */
                        if ((strcmp(etime,"0600") > 0)&&(strcmp(etime,"0830") <= 0))
                        {
                             tmp   = atoi(etime);
                             tmp   = tmp + 2400;
          
                             t_genexthh = get_hourterm_con(atoi(stime),tmp);
                             t_genextmm = get_minterm(atoi(stime),tmp);
                             
                        }
                        else
                        {
                             tmp   = atoi(etime);
                             tmp   = tmp + 2400;
          
                             t_genexthh = get_hourterm(atoi(stime),tmp);
                             t_genextmm = get_minterm(atoi(stime),tmp);
                             
                        }
          
                        return(SUCCESS);
                   }
                   else if (dd == 0)
                   {
                        if(((strcmp(stime,"0600") > 0)&&(strcmp(stime,"0830") <= 0))||
                           ((strcmp(etime,"0600") > 0)&&(strcmp(etime,"0830") <= 0)))
                        {
                             t_genexthh = get_hourterm_con(atoi(stime),atoi(etime));
                             t_genextmm = get_minterm(atoi(stime),atoi(etime));
                             
                        }
                        else
                        {
                             t_genexthh = get_hourterm(atoi(stime),atoi(etime));
                             t_genextmm = get_minterm(atoi(stime),atoi(etime));
                             
                        }
          
                        return(SUCCESS);
                   }
                   else if ((dd == 1)&&(daykind2 == 4))  // 날짜가 2일이면서 첫날이 휴일이 경우 일반연장 넣어줌.  kth.
                   {
                        tmp     = atoi(etime);
                        tmp     = tmp + 2400;
          
                        t_genexthh = get_hourterm(atoi(stime),tmp);
                        t_genextmm = get_minterm(atoi(stime),tmp);
                        
          
                        return(SUCCESS);
                   }
               }
               else
               {
                    t_genexthh = 0;
                    return(SUCCESS);
               }
          }
          else
          {    //h1, e1 이 아닐 경우 일반연장 계산해 줌. kth 정규직과 동일하게 시간계산.
               if  (daykind1 != 4)
               {
                    if ((dd==1) && (strcmp(etime,"0800") > 0))
                    {
                         tmp     = atoi("0800");
                         tmp     = tmp + 2400;
                         
                         t_genexthh = get_hourterm(atoi(stime),tmp);
                         t_genextmm = get_minterm(atoi(stime),tmp);
                         
                    }
                    else
                    {
                         t_genexthh = get_hourterm(atoi(stime),atoi(etime));
                         t_genextmm = get_minterm(atoi(stime),atoi(etime));
                         
                    }
                    return(SUCCESS);
               }
               else
               {
                    t_genexthh = 0;
                    t_genextmm = 0;
                    return(SUCCESS);
               }//h1, e1 이 아닐 경우 일반연장 계산해 줌. kth 정규직과 동일하게 시간계산 끝
          }
     }
     else if (strcmp(otflag,"G") == 0) /* 휴일 정상근무시 연장근무로 계산 */
     {
          t_genexthh = 0;
          t_genextmm = 0;
          return(SUCCESS);
     }
     
     return(SUCCESS);
}


/***************************************************************************
  일반연장시간을 처리하는 함수.
****************************************************************************/
get_genexthh(char *frtime,char *totime)
{
     int    tmp      = 0;
     int    dd       = 0;
     int    daykind  = 0;
     char   stime[5] = "";
     char   etime[5] = "";
     char   str[8+1] = "";

     strncpy(stime,frtime+8,4);
     strncpy(etime,totime+8,4);
     strncpy(str,frtime,8);
     daykind   = get_daykind(str);

     if  (daykind != 4)
     {
          dd = check_datetime(frtime,totime);
          if  (dd == FAIL)
               return(FAIL);
          
          /* 자율 책임 근무제 비대상자("N") 기존로직 적용 - 2018.08.17 Sangmoon Lee */
          if ( (strcmp(otflag,"N") == 0) ||
               ((strcmp(otflag," ") == 0) &&
                (((strcmp(sumYN,"Y") == 0) && (strcmp(curdate, SUMDATE) < 0)) ||
                 ((strcmp(sumYN,"N") == 0) && (strcmp(curdate, CALDATE) < 0)) )) )
          {
                if ((dd==1) && (strcmp(etime,"0800") > 0))
                {
                     tmp     = atoi("0800");
                     tmp     = tmp + 2400;
                     /*t_genexthh = get_hourterm(atoi(stime),tmp);
                       평일 근무시작시간을 정규근무시간내 등록한 경우 check 2015.10.13 jissi*/
                     if ((strcmp(stime,"0900") >= 0) && (strcmp(stime,"1800") <= 0))
                     {
                          t_genexthh = get_hourterm(atoi("1800"),tmp);
                          t_genextmm = get_minterm(atoi("1800"),tmp);
                     }
                     else
                     {
                          t_genexthh = get_hourterm(atoi(stime),tmp);
                          t_genextmm = get_minterm(atoi(stime),tmp);
                     }
                }
                else
                {
                     if  (dd == 1)
                     {
                          tmp   = atoi(etime);
                          tmp   = tmp + 2400;
                          /*t_genexthh = get_hourterm(atoi(stime),tmp);
                            평일 근무시작시간을 정규근무시간내 등록한 경우 check 2015.10.13 jissi*/
                          if ((strcmp(stime,"0900") >= 0) && (strcmp(stime,"1800") <= 0))
                          {
                               t_genexthh = get_hourterm(atoi("1800"),tmp);
                               t_genextmm = get_minterm(atoi("1800"),tmp);
                          }
                          else
                          {
                               t_genexthh = get_hourterm(atoi(stime),tmp);
                               t_genextmm = get_minterm(atoi(stime),tmp);
                          }
                     }
                     else
                     {
                          /*t_genexthh = get_hourterm(atoi(stime),atoi(etime));
                            평일 근무시작시간을 정규근무시간내 등록한 경우 check 2015.10.13 jissi*/
                          if ((strcmp(stime,"0900") >= 0) && (strcmp(stime,"1800") <= 0))
                          {
                               t_genexthh = get_hourterm(atoi("1800"),atoi(etime));
                               t_genextmm = get_minterm(atoi("1800"),atoi(etime));
                          }
                          else
                          {
                               t_genexthh = get_hourterm(atoi(stime),atoi(etime));
                               t_genextmm = get_minterm(atoi(stime),atoi(etime));
                          }
                     }
                }
          }
          /* 자율 근무제 로직 반영 - Sangmoon Lee 2018.06.14 */
          else if (strcmp(otflag,"O") == 0) /* 초과근무시 계산 */
          {
               if ((dd == 1) && (strcmp(etime,"0800") > 0) )
               {
                    tmp     = atoi("0800");
                    tmp     = tmp + 2400;

                    t_genexthh = get_hourterm(atoi(stime),tmp);
                    t_genextmm = get_minterm(atoi(stime),tmp);

               }
               else
               {
                    if  (dd == 1)
                    {
                         tmp   = atoi(etime);
                         tmp   = tmp + 2400;

                         t_genexthh = get_hourterm(atoi(stime),tmp);
                         t_genextmm = get_minterm(atoi(stime),tmp);

                    }
                    else
                    {
                         t_genexthh = get_hourterm(atoi(stime),atoi(etime));
                         t_genextmm = get_minterm(atoi(stime),atoi(etime));

                    }
               }
          }
          else if (strcmp(otflag,"G") == 0) /* 정상근무시 계산 X */
          {
               t_genexthh = 0;
               t_genextmm = 0;
          }
          return(SUCCESS);
     }
     else
     {
          t_genexthh = 0;
          t_genextmm = 0;
          return(SUCCESS);
     }
}

/*****************************************************************************
  기준월의 마지막 토요일을 구하는 함수.
 *****************************************************************************/
void get_lastsaturday(char* yymm, char* lastsaturday)
{
     char  t_date[8+1]  = "";
     char  t_dayname[20]  = "";

     get_lastday(yymm,t_date);
     while(1)
     {
          get_dayname(t_date,t_dayname);
          if  (strcmp(t_dayname,"SATURDAY") == 0)
               break;
          add_days(t_date,-1,t_date);
     }
     sprintf(lastsaturday,"%.8s",t_date);
}

/*****************************************************************************
  기준일+M 일을 구하는 함수.
 *****************************************************************************/
void add_days(char* indate,int m, char* rdate)
{
     EXEC SQL BEGIN DECLARE SECTION;
          char    t_date[8+1]  = "";
          double  t_adddays;
     EXEC SQL END DECLARE SECTION;

     sprintf(t_date,"%s",indate);
     t_adddays = m;

     EXEC SQL
     SELECT   TO_CHAR(TO_DATE(TO_CHAR(TO_DATE(:t_date,'YYYYMMDD')+
                                              :t_adddays,'YYYYMMDD'),'YYYYMMDD'),'YYYYMMDD')
     INTO  :t_date
     FROM  DUAL;

     sprintf(rdate,"%s",t_date);
}

/*****************************************************************************
  기준월의 마지막일을 구하는 함수.
 *****************************************************************************/
void get_lastday(char* yymm, char* result)
{
     EXEC SQL BEGIN DECLARE SECTION;
          char  basedate[9] = "";
     EXEC SQL END DECLARE SECTION;

     sprintf(basedate,"%.6s01",yymm);

     EXEC SQL
     SELECT   TO_CHAR(LAST_DAY(TO_DATE(:basedate,'YYYYMMDD')),'YYYYMMDD')
       INTO  :basedate
       FROM  DUAL;

     basedate[8] = '\0';
     sprintf(result,"%s",basedate);
}

/****************************************************************************
       요일명을 구하는 함수.
 ***************************************************************************/
void get_dayname(char *indate,char *result)
{
     EXEC SQL BEGIN DECLARE SECTION;
          char idate[8+1]   = "";
          char ddname[20] = "";
     EXEC SQL END   DECLARE SECTION;
     int count;

     strcpy(idate,indate);
     EXEC SQL
     SELECT  TO_CHAR(TO_DATE(:idate,'YYYYMMDD'),'DAY')
       INTO  :ddname
       FROM  DUAL;

     count = 0;
     while (ddname[count] != ' ')
          count++;

     ddname[count] = '\0';

     sprintf(result,"%s",ddname);
}

/****************************************************************************
  근무일의 종류를 결정하는 함수.
  1 -> 평일, 2 -> 휴무토요일, 3 -> 근무토요일, 4 -> 휴일
 ****************************************************************************/
get_daykind(char *indate)
{

     EXEC SQL BEGIN DECLARE SECTION;
          char day[8+1];
          int  count;
     EXEC SQL END   DECLARE SECTION;

     char dayname[100];
     int  i = 0;

     get_dayname(indate,dayname);
     if  (strcmp(dayname,"SUNDAY") == 0)
          return(4);

     sprintf(day,"%s",indate);
     count  = 0;
     /*2015.10.06 jissi 휴일/평일적용 특이자 체크 추가
     EXEC     SQL
     SELECT   COUNT(*)
       INTO  :count
       FROM   PKCHOLI
      WHERE   HOLIDATE = :day;
     */

     EXEC   SQL
     SELECT COUNT(*)
       INTO :count
       FROM
           (
            SELECT   HOLIDATE
              FROM   PKCHOLI
             WHERE   HOLIDATE = :day
            UNION
            SELECT   DUTYDATE
              FROM   PKHOLIEMP
             WHERE   DUTYDATE = :day
               AND   EMPNO    = :empno
               AND   DUKIND   = '49'     /*휴일적용*/
            MINUS
            SELECT   DUTYDATE
              FROM   PKHOLIEMP
             WHERE   DUTYDATE = :day
               AND   EMPNO    = :empno
               AND   DUKIND   = '00'     /*평일적용*/
           );
     /*printf("DEBUG count[%d],day[%s],empno[%s]\n",count,day, empno);*/
     if  (count >= 1)
     {
          i = 4;
          return(i);
     }

     if  (strcmp(dayname,"SATURDAY") == 0)
          i = 4;
     else
          i = 1;

     return(i);
}
 /************************************************************************
  휴일근로시간과 휴일연장근로시간을 구하는 함수.
 *************************************************************************/
process_holihh(char *frtime, char *totime)
{
     char    stime[5] = "";
     char    etime[5] = "";
     char    str[9]   = "";
     int     tmp      = 0;
     int     dd       = 0;
     int     daykind  = 0;
     double  a,b;
     int     a1,b1;

     strncpy(stime,frtime+8,4);
     strncpy(etime,totime+8,4);
     strncpy(str,frtime,8);

     daykind    = get_daykind(str);
     if  (daykind == 4)
     {
          dd = check_datetime(frtime,totime);
          if  (dd == FAIL)
               return(FAIL);
          
          /* 자율 근무제 로직 반영 - Sangmoon Lee 2018.06.14 */
          /* 자율 책임 근무제 비대상자("N") 기존로직 적용 - 2018.08.17 Sangmoon Lee */
          if ((strcmp(otflag,"N") == 0) || /* 초과근무시 모두 계산 */
              ((strcmp(sumYN,"Y") == 0) && (strcmp(curdate, SUMDATE) < 0)) ||
              ((strcmp(sumYN,"N") == 0) && (strcmp(curdate, CALDATE) < 0)) )
          {
               if ((dd==1) && (strcmp(etime,"0800") > 0) )
               {
                    tmp    = atoi("0800");
                    tmp   = tmp + 2400;
                    a = get_hourterm(atoi(stime),tmp);
                    b = get_hourterm(atoi("0800"),atoi(etime));

                    a1 = get_minterm(atoi(stime),tmp);
                    b1 = get_minterm(atoi("0800"),atoi(etime));

                    t_holihh = a + b;
                    t_holimm = a1 + b1;

                    if  (a > 8)
                    {
                         t_holiexthh = a - 8;
                         t_holiextmm = a1 - (8 * 60);
                    }
                    if  (b > 8)
                    {
                         t_holiexthh = t_holiexthh + (b - 8);
                         t_holiextmm = t_holiextmm + (b1 - (8 * 60));
                    }
               }
               else
               {
                    if  (dd == 1)
                    {
                         tmp      = atoi(etime);
                         tmp      = tmp + 2400;
                         t_holihh = get_hourterm(atoi(stime),tmp);
                         t_holimm = get_minterm(atoi(stime),tmp);
                    }
                    else
                    {
                         t_holihh = get_hourterm(atoi(stime), atoi(etime));
                         t_holimm = get_minterm(atoi(stime), atoi(etime));
                    }

                    if  (t_holihh > 8)
                    {
                         t_holiexthh = t_holihh - 8;
                         t_holiextmm = t_holimm - (8 * 60);
                    }
               }
          }
          else if (strcmp(otflag,"O") == 0) /* 초과근무시 모두 계산 */
          {
               if ((dd==1) && (strcmp(etime,"0800") > 0) )
               {
                    tmp    = atoi("0800");
                    tmp   = tmp + 2400;
                    a = get_hourterm(atoi(stime),tmp);
                    b = get_hourterm(atoi("0800"),atoi(etime));

                    a1 = get_minterm(atoi(stime),tmp);
                    b1 = get_minterm(atoi("0800"),atoi(etime));

                    t_holihh = a + b;
                    t_holimm = a1 + b1;
                    
                    /* 초과근무시 휴일근로시간 = 휴일연장시간 - Sangmoon Lee 2018.06.14 */
                    t_holiexthh = t_holihh;
                    t_holiextmm = t_holimm;

               }
               else
               {
                    if  (dd == 1)
                    {
                         tmp      = atoi(etime);
                         tmp      = tmp + 2400;
                         t_holihh = get_hourterm(atoi(stime),tmp);
                         t_holimm = get_minterm(atoi(stime),tmp);
                    }
                    else
                    {
                         t_holihh = get_hourterm(atoi(stime), atoi(etime));
                         t_holimm = get_minterm(atoi(stime), atoi(etime));
                    }
                    
                    /* 초과근무시 휴일근로시간 = 휴일연장시간 - Sangmoon Lee 2018.06.14 */
                    t_holiexthh = t_holihh;
                    t_holiextmm = t_holimm;
               }
          }
          else if (strcmp(otflag,"G") == 0) /* 휴일 정상근무시 연장근무로 계산 */
          {
               if  (dd == 1)
               {
                    tmp      = atoi(etime);
                    tmp      = tmp + 2400;
                    t_holiexthh = get_hourterm(atoi(stime),tmp);
                    t_holiextmm = get_minterm(atoi(stime),tmp);
               }
               else
               {
                    t_holiexthh = get_hourterm(atoi(stime), atoi(etime));
                    t_holiextmm = get_minterm(atoi(stime), atoi(etime));
               }
          }
     }

     return(SUCCESS);
}
/****************************************************************************
   계산된 근무시간을 DB에 저장하는 Procedure.
 ****************************************************************************/
update_record()
{
     char    dname[100+1]  = "";
     /*double  tongpay;*/
     int     daykind;
     double  ovtmnightamt;  /*dsa2000 */
     char    t_date[8+1]  = "";
     char    t_chkdate[5]  = "";

     if (strcmp(sumYN, "Y") == 0)
     {
          EXEC SQL
          SELECT  case when :ovtmdate < :comchdate                      /*2017.01.01이후 초과근무수당 계산할 때 통상임금이 기준시간 226hr->209hr*/
                       then hper.COMMONUTIL.GET_OLDBASEPAY(:empno,:yearpaynum)
                       else hper.COMMONUTIL.GET_NEWBASEPAY(:empno,:yearpaynum) end  /*DB package에서 계산 jissi. 2016.12.14*/
            INTO :tongpay
            FROM DUAL;
     }
     else if (strcmp(sumYN, "N") == 0)
     {
          tongpay  = tongpay;
     }

     
     /*2016.08.24 jissi HR팀 홍원영M 요청 SR-1608-0885
       휴일근로시간이 1시간인 경우 기존처럼 식사제외시간을 제외하지 않고 0으로 반영
       ※단, 일반연장근로는 제외함. */
     if ((t_holihh == 1) && (t_genexthh == 0) && (t_holiexthh == 0))
          t_mealhh = 0;

     /******************************************************************************/
     /* 초과근무수당 계산번경(10분단위 절사, 잔여분 이월 - 2017.11.20 SangMoon Lee */

     pre_PKHOTFWD(); /* 전월 이월 데이터 조회 */

     EXEC SQL
     SELECT  PRE_GENEXTSUM, PRE_HOLIEXTSUM, PRE_NIGHTSUM,
             PRE_HOLISUM, PRE_MEALSUM, PRE_RESTSUM, PRE_SPRESTSUM
       INTO  :pre_genextsum, :pre_holiextsum, :pre_nightsum,
             :pre_holisum, :pre_mealsum, :pre_restsum, :pre_sprestsum
       FROM  PKHOTFWD
      WHERE  EMPNO    = :empno
        AND  OVTMYYMM = :workmm;


     /* 10분 절사 */
     t_genextmm  = floor(t_genextmm  / 10) * 10;
     t_holiextmm = floor(t_holiextmm / 10) * 10;
     t_nightmm   = floor(t_nightmm   / 10) * 10;
     t_holimm    = floor(t_holimm    / 10) * 10;
     t_mealmm    = floor(t_mealmm    / 10) * 10;
     t_restmm    = floor(t_restmm    / 10) * 10;
     t_sprestmm  = floor(t_sprestmm  / 10) * 10;

     /* 일반연장 */
     t_genexthh     = (int)t_genextmm / 60;
     pre_genextsum  = pre_genextsum + (t_genextmm % 60);
     /* 휴일연장 */
     t_holiexthh    = (int)t_holiextmm / 60;
     pre_holiextsum = pre_holiextsum + (t_holiextmm % 60);
     /* 야간근로 */
     t_nighthh      = (int)t_nightmm / 60;
     pre_nightsum   = pre_nightsum + (t_nightmm % 60);
     /* 휴일근로 */
     t_holihh       = (int)t_holimm / 60;
     pre_holisum    = pre_holisum + (t_holimm % 60);
     /* 식사시간 */
     t_mealhh       = (int)t_mealmm / 60;
     pre_mealsum    = pre_mealsum + (t_mealmm % 60);

     /******************************************************************************/

     t_extamt   = (t_genexthh * tongpay * 1.5) +
                  (t_holiexthh* tongpay * 0.5);
     t_nightamt =  t_nighthh  * tongpay * 0.5;
     t_holiamt  =  t_holihh   * tongpay * 1.5;
     t_mealamt  =  t_mealhh   * tongpay * 1.5;
     t_excepamt =  t_excephh  * tongpay * 1.5;

     t_extamt   = ceil(t_extamt);
     t_nightamt = ceil(t_nightamt);
     t_holiamt  = ceil(t_holiamt);
     t_mealamt  = floor(t_mealamt);
     t_excepamt = floor(t_excepamt);

/*sprintf(log_buff, "\n [DEBUG] holiexthh=%f, tongpay=%f, holiextamt=%f"
                , t_holiexthh, tongpay, (t_holiexthh* tongpay * 0.5));
Write_batlog(seqno++, log_buff);

sprintf(log_buff, "\n [DEBUG] nighthh=%f, nightamt=%f"
                , t_nighthh, t_nightamt);
Write_batlog(seqno++, log_buff);*/
     ovtmhh     = get_ovtmhh(frrealtime,torealtime);

     /* 초과근무수당 계산번경(10분단위 절사, 잔여분 이월 - 2017.11.20 SangMoon Lee */
     /* ==============================================
         초과근무에서 휴식시간분만큼을 제외하는 로직 추가
      * ============================================== */
     
     /* 자율책임 근무제 도입으로 근무제별 가산 분리 - 2018.08.20 Sangmoon Lee */
     /* 
      * N : *1.5
      * G : *0.5
      * O : 평일 *1.5, 휴일 *2.0
      */
     //t_restamt   = floor((int)t_restmm/60  * tongpay * 1.5);
     if (strcmp(otflag,"N") == 0) /* 비대상자 */
     {
          t_restamt   = floor((int)t_restmm/60  * tongpay * 1.5);
     }
     else if (strcmp(otflag,"G") == 0) /* 정상(휴일/야간) */
     {
          t_restamt   = floor((int)t_restmm/60  * tongpay * 0.5);
     }
     else if (strcmp(otflag,"O") == 0) /* 초과근무 */
     {
          if ( t_holihh > 0 )
          {
               t_restamt   = floor((int)t_restmm/60  * tongpay * 2.0);
          }
          else
          {
               t_restamt   = floor((int)t_restmm/60  * tongpay * 2.0);
          }
     }
     pre_restsum = pre_restsum + (t_restmm % 60);

     /* ==============================================
         일상근무에서 휴식시간분만큼을 제외하는 로직 추가
      * ============================================== */
     t_sprestamt   = floor((int)t_sprestmm/60 * tongpay );
     pre_sprestsum = pre_sprestsum + (t_sprestmm % 60);

     /* 자율책임 근무제 도입으로 식사시간, 9이상 제외급 미적용. HR팀 박명언M 요청 - 2018.08.09 Sangmoon Lee */
     /* 자율 책임 근무제 대상자("G","O") 식사시간,9이상제외 삭제 */
     /* 자율 책임 근무제 비대상자("N") 기존로직 적용 - 2018.08.17 Sangmoon Lee */
     if (strcmp(otflag,"N") == 0)
     {
          total_amt  = total_amt + (t_extamt + t_nightamt + t_holiamt)
                     - t_restamt - t_sprestamt - t_mealamt - t_excepamt ;
     }
     else if ((strcmp(otflag,"O") == 0) || 
         ((strcmp(sumYN,"Y") == 0) && (strcmp(curdate, SUMDATE) < 0)) ||
         ((strcmp(sumYN,"N") == 0) && (strcmp(curdate, CALDATE) < 0)) )
     {
          total_amt  = total_amt + (t_extamt + t_nightamt + t_holiamt)
                     - t_restamt - t_sprestamt /*- t_mealamt - t_excepamt*/ ;
     }
     else if (strcmp(otflag,"G") == 0)
     {
          total_amt  = total_amt + (t_extamt + t_nightamt + t_holiamt)
                     - t_restamt /*- t_sprestamt*//* - t_mealamt - t_excepamt*/ ;
     }

     if  (total_amt <= 0 )
          printf("\n 오류자료입니다. 사번[%s],성명[%s],초과근무일[%s] 11", empno,korname,ovtmdate);

     /* 야근식대처리부분 */
     sprintf(t_date,"%.8s",ovtmdate);
     daykind    = get_daykind(t_date);

     switch (daykind)
     {
          case 2 :
          case 3 :
          case 4 :
               ovmcamt = 0;
               break;
          case 1 :

/* dsa2000 2004.08.27. 야근식대 DB에서 읽어오도록 변경 -초과근무기준관리에서 변경 가능 */
          EXEC SQL
          SELECT OVTMNIGHTAMT
            INTO :ovtmnightamt
            FROM PKCOTBAS;

/* dsa2000 end ===============================================================================*/
     }


     strncpy(t_chkdate,frrealtime+8,4);
     
     /* 자율 책임 근무제 대상자("G","O") 야간근로시 적용 */
     /* 자율 책임 근무제 비대상자("N") 기존로직 적용 - 2018.08.17 Sangmoon Lee */
     if (strcmp(otflag,"N") == 0)
     {
          if ( strcmp(t_chkdate,"1800") >= 0 )
          {
               ovmcamt = ovtmnightamt;
          }
     }
     else if ((strcmp(otflag,"O") == 0) || (strcmp(otflag,"G") == 0))
     {
          if ( t_nighthh > 0 )
          {
               ovmcamt = ovtmnightamt;
          }
     }
     else
     {
          ovmcamt = 0;
     }


     EXEC SQL
     UPDATE  PKHOTHIS
        SET  EXTHH        = (:t_genexthh + :t_holiexthh),
             NIGHTHH      = :t_nighthh,
             HOLIHH       = :t_holihh,
             GENEXT       = :t_genexthh,
             HOLIEXT      = :t_holiexthh,
             OVTMHH       = :ovtmhh,
             OVMCAMT      = :ovmcamt,
             EXTAMT       = :t_extamt,
             NIGHTAMT     = :t_nightamt,
             HOLIAMT      = :t_holiamt,
             OVTMAMT      = (:t_extamt + :t_nightamt + :t_holiamt - :t_restamt - :t_sprestamt- :t_mealamt - :t_excepamt ),
             RESTAMT      = :t_restamt,
             SPRESTAMT    = :t_sprestamt ,
             MEALHH       = :t_mealhh,
             MEALAMT      = :t_mealamt ,
             EXCEPHH      = :t_excephh,
             EXCEPAMT     = :t_excepamt,
             WRITETIME    = TO_Char(sysdate,'YYYYMMDDHH24MISS'),
             WRITEMAN     = :jobempno
      WHERE  EMPNO        = :empno AND OVTMDATE = :ovtmdate
        AND  NVL(FRAPPTIME,'*')  = :frapptime
        AND  NVL(FRREALTIME,'*') = :frrealtime;

     if  (sqlca.sqlcode != 0)
     {
          printf("ERROR_CODE : %d, UPDATE ERROR\n", sqlca.sqlcode);
          return(FAIL);
     }
     //else
     //     return(SUCCESS);

     /******************************************************************************/
     /* 초과근무수당 계산번경(10분단위 절사, 잔여분 이월 - 2017.11.20 SangMoon Lee */
     EXEC SQL
     UPDATE  PKHOTFWD
        SET  STATE           = 2
            ,PRE_GENEXTSUM   = :pre_genextsum
            ,PRE_HOLIEXTSUM  = :pre_holiextsum
            ,PRE_NIGHTSUM    = :pre_nightsum
            ,PRE_HOLISUM     = :pre_holisum
            ,PRE_MEALSUM     = :pre_mealsum
            ,PRE_RESTSUM     = :pre_restsum
            ,PRE_SPRESTSUM   = :pre_sprestsum
            ,WRITETIME       = TO_Char(sysdate,'YYYYMMDDHH24MISS')
            ,WRITEMAN        = TO_Char(:jobempno)
      WHERE  EMPNO           = TO_Char(:empno   )
        AND  OVTMYYMM        = TO_Char(:workmm  )
     ;

     if  (sqlca.sqlcode != 0)
     {
          printf("ERROR_CODE : %d, UPDATE ERROR\n", sqlca.sqlcode);
          return(FAIL);
     }
     else
          return(SUCCESS);
     /******************************************************************************/
}

/****************************************************************************
  초과근무월별집계를 수행하는 Procedure1.
 ****************************************************************************/
process_sumstep1()
{

     EXEC SQL DECLARE cursor2 CURSOR FOR

     SELECT  A.EMPNO, COUNT(*), SUM(EXTHH), SUM(NIGHTHH),
             SUM(HOLIHH), SUM(OVTMHH), SUM(GENEXT), SUM(HOLIEXT),
             SUM(EXTAMT), SUM(NIGHTAMT), SUM(HOLIAMT), SUM(OVTMAMT),
             SUM(OVTMHH), SUM(OVMCAMT), B.TOTPAY
       FROM  PKHOTHIS A, PKHYPHIS B
      WHERE  A.EMPNO = B.EMPNO
        AND  B.YEARPAYNUM = :yearpaynum
        AND  SUBSTR(OVTMDATE,1,6) = :workmm
        AND  ( A.EMPNO >= :frempno AND A.EMPNO <= :toempno )
        AND  ( UPPER(NVL(CONYN,' ')) = 'Y' )
      GROUP BY A.EMPNO, B.TOTPAY
      ORDER BY A.EMPNO;

     EXEC SQL OPEN cursor2;
     if ((sqlca.sqlcode != 1403) && (sqlca.sqlcode != 0) &&
         (sqlca.sqlcode != -1405))
     {
          EXEC SQL CLOSE cursor2;
          printf("ERROR_CODE : %d, 추출된 자료에 이상이 있습니다.\n", sqlca.sqlcode);
          sprintf(log_buff, "ERROR_CODE : %d, 추출된 자료에 이상이 있습니다.\n", sqlca.sqlcode); /*dsa2000 Rexec 대체*/
          Write_batlog(seqno++, log_buff);
          return(FAIL);
     }

     s_count = f_count = 0;
     while(1)
     {
          EXEC SQL FETCH cursor2
          INTO :empno, :s_totdd, :s_exthh, :s_nighthh,
               :s_holihh, :s_tothh, :s_genext, :s_holiext,
               :s_extamt, :s_nightamt, :s_holiamt, :s_ovtmamt,
               :s_ovtmhh, :s_ovmcamt, :totpay;

          if  (sqlca.sqlcode == 1403)
          {
               EXEC SQL CLOSE cursor2;
               return(SUCCESS);
          }

          if  (calc_sum1() == SUCCESS)
          {
               s_count++;
          }
          else
          {
               f_count++;
               printf("[집계단계1]에 실패한 EMPNO : %s \n", empno);
          }
     }


}



/**************************************************************************
  기본인사사항과 시간별집계를 처리한다.
 **************************************************************************/
calc_sum1()
{
     EXEC SQL BEGIN DECLARE SECTION;
          double  tongpay;

          /* 전,당월합 60분 이상시 사용. 시간 임시변수 */
          int     tmp_genexthh  = 0;
          int     tmp_holiexthh = 0;
          int     tmp_nighthh   = 0;
          int     tmp_holihh    = 0;
          int     tmp_mealhh    = 0;
          int     tmp_restmm    = 0;
          int     tmp_sprestmm  = 0;

          /* 임금 임시변수 */
          double  tmp_extamt    = 0;
          double  tmp_nightamt  = 0;
          double  tmp_holiamt   = 0;
          double  tmp_mealamt   = 0;
          double  tmp_excepamt  = 0;
          double  tmp_restamt   = 0;
          double  tmp_sprestamt = 0;
          double  tmp_ovtmamt   = 0;

          int     tmp_exthh     = 0;
     EXEC SQL END DECLARE SECTION;

     EXEC SQL
     DELETE  PKHOTSUM
      WHERE  EMPNO    = :empno
        AND   OVTMYYMM = :workmm;

     if ((sqlca.sqlcode != 0) && (sqlca.sqlcode != 1403)  )
     {
          printf("ERROR_CODE : %d, 삭제 실패\n", sqlca.sqlcode);
          sprintf(log_buff, "ERROR_CODE : %d, 삭제 실패\n", sqlca.sqlcode); /*dsa2000 Rexec 대체*/
          Write_batlog(seqno++, log_buff);
          return(FAIL);
     }

     EXEC SQL
     INSERT INTO PKHOTSUM
             (OVTMYYMM, EMPNO, KORNAME, PAYCL, PAYGR, PAYRA, ORGNUM, DEPTCODE)
     SELECT   PAYDATE, EMPNO, KORNAME, PAYCL, PAYGR, PAYRA, ORGNUM, DEPTCODE
       FROM  PKHPHIS
      WHERE  EMPNO   = :empno
        AND   PAYDATE = :workmm;

     if ((sqlca.sqlcode != 0) && (sqlca.sqlcode != 1403)  )
     {
          printf("ERROR_CODE : %d, 기본인사사항 생성실패1\n", sqlca.sqlcode);
          sprintf(log_buff, "ERROR_CODE : %d, 기본인사사항 생성실패1\n", sqlca.sqlcode); /*dsa2000 Rexec 대체*/
          Write_batlog(seqno++, log_buff);
          return(FAIL);
     }

     EXEC SQL
     INSERT  INTO PKHOTSUM
            (OVTMYYMM, EMPNO, KORNAME, PAYCL, PAYGR, PAYRA, ORGNUM, DEPTCODE)
     SELECT   :workmm, EMPNO, KORNAME, PAYCL, PAYGR, PAYRA, ORGNUM, DEPTCODE
     FROM  PKMPMAS
     WHERE  EMPNO   = :empno
     AND   (0 = (SELECT COUNT(*)
                   FROM   PKHOTSUM
                  WHERE  EMPNO = :empno AND OVTMYYMM = :workmm));
     if ((sqlca.sqlcode != 0) && (sqlca.sqlcode != 1403))
     {
          printf("ERROR_CODE : %d, 기본인사사항 생성실패2\n", sqlca.sqlcode);
          sprintf(log_buff, "ERROR_CODE : %d, 기본인사사항 생성실패2\n", sqlca.sqlcode); /*dsa2000 Rexec 대체*/
          Write_batlog(seqno++, log_buff);
          return(FAIL);
     }

     EXEC  SQL
     UPDATE  PKHOTSUM
        SET TONGPAY = (case when OVTMYYMM < :comchdate                        /*2017.01.01이후 초과근무수당 계산할 때 통상임금이 기준시간 226hr->209hr*/
                            then hper.COMMONUTIL.GET_OLDBASEPAY(EMPNO,:yearpaynum)
                            else hper.COMMONUTIL.GET_NEWBASEPAY(EMPNO,:yearpaynum) end)
     WHERE  EMPNO = :empno AND OVTMYYMM = :workmm;

     if ((sqlca.sqlcode != 0)  && (sqlca.sqlcode != 1403))
     {
          printf("ERROR_CODE : %d, 통상임금 반영실패\n", sqlca.sqlcode);
          sprintf(log_buff, "ERROR_CODE : %d, 통상임금 반영실패\n", sqlca.sqlcode); /*dsa2000 Rexec 대체*/
          Write_batlog(seqno++, log_buff);
          return(FAIL);
     }
     /******************************************************************************/
     /* 초과근무수당 계산번경(10분단위 절사, 잔여분 이월 - 2017.11.20 SangMoon Lee */
     // 개인별 PKHOTFWD 조회 -> 이월 게산 -> 시간단위 당월 합산 -> 이훨 Update
     EXEC SQL
     SELECT  PRE_GENEXTSUM, PRE_HOLIEXTSUM, PRE_NIGHTSUM,
             PRE_HOLISUM, PRE_MEALSUM, PRE_RESTSUM, PRE_SPRESTSUM
       INTO  :pre_genextsum, :pre_holiextsum, :pre_nightsum,
             :pre_holisum, :pre_mealsum, :pre_restsum, :pre_sprestsum
       FROM  PKHOTFWD
      WHERE  EMPNO    = :empno
        AND  OVTMYYMM = :workmm;

     /* 60분 이상시 시간 보관 */
     if (pre_genextsum % 60 >= 0)
     {
       tmp_genexthh = (int)pre_genextsum / 60;
       nxt_genextmm   = pre_genextsum % 60;
     }

     if (pre_holiextsum % 60 >= 0)
     {
       tmp_holiexthh = (int)pre_holiextsum / 60;
       nxt_holiextmm = pre_holiextsum % 60;
     }

     if (pre_nightsum % 60 >= 0)
     {
       tmp_nighthh = (int)pre_nightsum / 60;
       nxt_nightmm = pre_nightsum % 60;
     }

     if (pre_holisum % 60 >= 0)
     {
       tmp_holihh = (int)pre_holisum / 60;
       nxt_holimm = pre_holisum % 60;
     }

     if (pre_mealsum % 60 >= 0)
     {
       tmp_mealhh = (int)pre_mealsum / 60;
       nxt_mealmm = pre_mealsum % 60;
     }

     if (pre_restsum % 60 >= 0)
     {
       tmp_restmm = ((int)pre_restsum / 60) * 60;
       nxt_restmm = pre_restsum % 60;
     }

     if (pre_sprestsum % 60 >= 0)
     {
       tmp_sprestmm = ((int)pre_sprestsum / 60) * 60;
       nxt_sprestmm = pre_sprestsum % 60;
     }

     tmp_exthh = tmp_genexthh + tmp_holiexthh;
     /* 60분 이상시 시간 보관 end */


     EXEC SQL
     SELECT  case when :ovtmdate < :comchdate                      /*2017.01.01이후 초과근무수당 계산할 때 통상임금이 기준시간 226hr->209hr*/
                  then hper.COMMONUTIL.GET_OLDBASEPAY(:empno,:yearpaynum)
                  else hper.COMMONUTIL.GET_NEWBASEPAY(:empno,:yearpaynum) end  /*DB package에서 계산 jissi. 2016.12.14*/
       INTO :tongpay
       FROM DUAL;

     /* 임금계산 */
     tmp_extamt    = (tmp_genexthh  * tongpay * 1.5) +
                     (tmp_holiexthh * tongpay * 0.5);
     tmp_nightamt  =  tmp_nighthh   * tongpay * 0.5;
     tmp_holiamt   =  tmp_holihh    * tongpay * 1.5;
     tmp_mealamt   =  tmp_mealhh    * tongpay * 1.5;
     tmp_restamt   =  floor((int)tmp_restmm/60  * tongpay * 1.5);
     tmp_sprestamt =  floor((int)tmp_sprestmm/60 * tongpay );

     tmp_extamt    = ceil(tmp_extamt);
     tmp_nightamt  = ceil(tmp_nightamt);
     tmp_holiamt   = ceil(tmp_holiamt);
     tmp_mealamt   = floor(tmp_mealamt);

     tmp_ovtmamt  = (tmp_extamt + tmp_nightamt + tmp_holiamt)
                  - tmp_restamt - tmp_sprestamt - tmp_mealamt;
     /* 임금계산 end */

     /******************************************************************************/
     EXEC SQL
     UPDATE  PKHOTSUM
        SET
             TOTDD    = :s_totdd,
             OVTMDD   = :s_totdd,
             EXTHH    = (:s_exthh+:tmp_exthh),
             NIGHTHH  = (:s_nighthh+:tmp_nighthh),
             HOLIHH   = (:s_holihh+:tmp_holihh),
             OVERHH   = (:s_exthh+:s_nighthh+:s_holihh+:tmp_exthh+:tmp_nighthh+:tmp_holihh),
             TOTHH    = (:s_exthh+:s_nighthh+:s_holihh+:tmp_exthh+:tmp_nighthh+:tmp_holihh),
             GENEXT   = (:s_genext+:tmp_genexthh),
             HOLIEXT  = (:s_holiext+:tmp_holiexthh),
             EXTAMT   = (:s_extamt+:tmp_extamt),
             NIGHTAMT = (:s_nightamt+:tmp_nightamt),
             HOLIAMT  = (:s_holiamt+:tmp_holiamt),
             OVERAMT  = (:s_ovtmamt+:tmp_ovtmamt),
             OVTMAMT  = (:s_ovtmamt+:tmp_ovtmamt),
             OVMCAMT  = :s_ovmcamt,
             REALHH   = :s_ovtmhh
      WHERE  EMPNO    = :empno
        AND  OVTMYYMM = :workmm;
     if  (sqlca.sqlcode != 0)
     {
         printf("ERROR_CODE : %d, 시간별집계 실패\n",sqlca.sqlcode);
         sprintf(log_buff, "ERROR_CODE : %d, 시간별집계 실패\n", sqlca.sqlcode); /*dsa2000 Rexec 대체*/
         Write_batlog(seqno++, log_buff);
         return(FAIL);
     }
     //else
     //	 return(SUCCESS);

     /******************************************************************************/
     /* 초과근무수당 계산번경(10분단위 절사, 잔여분 이월 - 2017.11.20 SangMoon Lee */
     EXEC SQL
     UPDATE  PKHOTFWD
        SET  STATE           = 3
            ,NXT_GENEXT      = :nxt_genextmm
            ,NXT_HOLIEXT     = :nxt_holiextmm
            ,NXT_NIGHT       = :nxt_nightmm
            ,NXT_HOLI        = :nxt_holimm
            ,NXT_MEAL        = :nxt_mealmm
            ,NXT_REST        = :nxt_restmm
            ,NXT_SPREST      = :nxt_sprestmm
            ,WRITETIME       = TO_Char(sysdate,'YYYYMMDDHH24MISS')
            ,WRITEMAN        = :jobempno
      WHERE  EMPNO           = :empno
        AND  OVTMYYMM        = :workmm;

     if  (sqlca.sqlcode != 0)
     {
          printf("ERROR_CODE : %d, UPDATE ERROR\n", sqlca.sqlcode);
          return(FAIL);
     }
     else
          return(SUCCESS);
     /******************************************************************************/
}

/* ===============================================================================
 Version  date(yy.mm.dd)  programmer    description                        relevant doc.no
 30.30    2001.11.13.      유효성       근태테이블(pkhduty)의 대휴(repoff)및 교휴를 불러와
                                        최종계산된 초과수당(pkhotsum의 ovtmamt)에서 빼는 로직 추가.
 ============================================================================= */
process_repoff()
{
    /*pkhotsum table에 없는 사원은 INSERT*/
     EXEC SQL
     INSERT   INTO PKHOTSUM
            (OVTMYYMM, EMPNO, KORNAME, PAYCL, PAYGR, PAYRA, ORGNUM, DEPTCODE, WRITEMAN)
     SELECT   :workmm, EMPNO, KORNAME, PAYCL, PAYGR, PAYRA, ORGNUM, DEPTCODE, '****'
       FROM  PKMPMAS
      WHERE  (EMPNO >= :frempno AND EMPNO <= :toempno )
        AND  EMPNO   IN (SELECT   EMPNO
                           FROM   PKHDUTY
                          WHERE   DUYYMM = :workmm
                            AND   (NVL(REPOFF, 0) <> 0  or NVL(SPEOFF,0) <> 0)
                            AND   EMPNO  NOT IN (SELECT EMPNO
                                                   FROM PKHOTSUM
                                                  WHERE OVTMYYMM = :workmm )) ;

     if ((sqlca.sqlcode != 0) && (sqlca.sqlcode != 1403))
     {
          printf("ERROR_CODE : %d, 기본인사사항 생성실패3\n", sqlca.sqlcode);
          sprintf(log_buff, "ERROR_CODE : %d, 기본인사사항 생성실패3\n", sqlca.sqlcode); /*dsa2000 Rexec 대체*/
          Write_batlog(seqno++, log_buff);
          return(FAIL);
     }

     EXEC SQL
     UPDATE PKHOTSUM A
        SET TONGPAY  = (case when OVTMYYMM < :comchdate                        /*2017.01.01이후 초과근무수당 계산할 때 통상임금이 기준시간 226hr->209hr*/
                            then hper.COMMONUTIL.GET_OLDBASEPAY(EMPNO,:yearpaynum)
                            else hper.COMMONUTIL.GET_NEWBASEPAY(EMPNO,:yearpaynum) end)
      WHERE OVTMYYMM = :workmm
        AND (EMPNO >= :frempno AND EMPNO <= :toempno )
        AND WRITEMAN ='****' ;
     if ((sqlca.sqlcode != 0) && (sqlca.sqlcode != 1403) )
     {
          printf("ERROR_CODE : %d, 통상임금 UPDATE 실패\n", sqlca.sqlcode);
          sprintf(log_buff, "ERROR_CODE : %d, 통상임금 UPDATE 실패\n", sqlca.sqlcode); /*dsa2000 Rexec 대체*/
          Write_batlog(seqno++, log_buff);
          return(FAIL);
     }

   /*교휴갯수 UPDATE 20090427 KTH 추가*/
     EXEC SQL
     UPDATE  PKHOTSUM A
        SET  SPEOFFDD = (SELECT NVL(SPEOFF,0)
                           FROM PKHDUTY B
                          WHERE A.EMPNO = B.EMPNO
                            AND B.DUYYMM = :workmm)
     WHERE OVTMYYMM = :workmm
       AND (EMPNO >= :frempno AND EMPNO <= :toempno )
       AND EMPNO IN (SELECT EMPNO FROM PKHDUTY
                      WHERE DUYYMM = :workmm
                        AND NVL(SPEOFF,0) <> 0 ) ;


     if ((sqlca.sqlcode != 0) && (sqlca.sqlcode != 1403) )
     {
          printf("ERROR_CODE : %d, 교휴갯수 UPDATE 실패\n", sqlca.sqlcode);
          sprintf(log_buff, "ERROR_CODE : %d, 교휴갯수UPDATE 실패\n", sqlca.sqlcode); /*dsa2000 Rexec 대체*/
          Write_batlog(seqno++, log_buff);
          return(FAIL);
     }

   /*교휴금액 UPDATE 20090427 KTH 추가 */
     EXEC SQL
     UPDATE  PKHOTSUM A
        SET  SPEOFFAMT = ceil(NVL(SPEOFFDD,0) * :rephh * NVL(TONGPAY,0) )
      WHERE  OVTMYYMM = :workmm
        AND  (EMPNO >= :frempno AND EMPNO <= :toempno )
        AND  EMPNO IN (SELECT EMPNO FROM PKHDUTY
                        WHERE DUYYMM = :workmm
                          AND NVL(SPEOFF,0) <> 0 ) ;

     if  ((sqlca.sqlcode != 0) && (sqlca.sqlcode != 1403) )
     {
          printf("ERROR_CODE : %d, 교휴금액 UPDATE 실패\n", sqlca.sqlcode);
          sprintf(log_buff, "ERROR_CODE : %d, 교휴금액UPDATE 실패\n", sqlca.sqlcode); /*dsa2000 Rexec 대체*/
          Write_batlog(seqno++, log_buff);
          return(FAIL);
     }



   /*최종초과수당 UPDATE*/
     EXEC SQL
     UPDATE  PKHOTSUM A
        SET  OVTMAMT = NVL(OVERAMT, 0) - NVL(REPOFFAMT, 0)- NVL(SPEOFFAMT, 0),
             WRITETIME = to_char(sysdate,'yyyymmddhh24mi'),
             WRITEMAN  = :jobempno
      WHERE  OVTMYYMM = :workmm
        AND (EMPNO >= :frempno AND EMPNO <= :toempno ) ;

     if ((sqlca.sqlcode != 0) && (sqlca.sqlcode != 1403) )
     {
          printf("ERROR_CODE : %d, 최종초과수당 UPDATE 실패\n", sqlca.sqlcode);
          sprintf(log_buff, "ERROR_CODE : %d, 최종초과수당 UPDATE 실패\n", sqlca.sqlcode); /*dsa2000 Rexec 대체*/
          Write_batlog(seqno++, log_buff);
          return(FAIL);
     }


     return(SUCCESS);

}



/****************************************************************************
  초과근무월별집계를 수행하는 Procedure2.
 ****************************************************************************/
process_sumstep2()
{
     char  t_empno[4+1]  = "";

     EXEC SQL DECLARE cursor3 CURSOR FOR
     SELECT  EMPNO, DAYKIND, SUM(OVTMHH), SUM(OVTMAMT)
       FROM  PKHOTHIS
      WHERE  SUBSTR(OVTMDATE,1,6) = :workmm
        AND  ( EMPNO >= :frempno AND EMPNO <= :toempno )
        AND  ( UPPER(NVL(CONYN,' ')) = 'Y' )
      GROUP  BY EMPNO, DAYKIND
      ORDER  BY EMPNO, DAYKIND;

     EXEC SQL OPEN cursor3;
     if ((sqlca.sqlcode != 1403) && (sqlca.sqlcode != 0) && (sqlca.sqlcode != -1405))
     {
          printf("ERROR_CODE : %d, OPEN cursor3 Error...\n", sqlca.sqlcode);
          sprintf(log_buff, "ERROR_CODE : %d, OPEN cursor3 Error..\n", sqlca.sqlcode); /*dsa2000 Rexec 대체*/
          Write_batlog(seqno++, log_buff);
          EXEC SQL CLOSE cursor3;
          return(FAIL);
     }


     s_count = f_count = 0;
     while(1)
     {
          EXEC SQL FETCH cursor3
          INTO :empno, :daykind, :s_tothh, :s_ovtmamt;
          if  (sqlca.sqlcode == 1403)
          {
               EXEC SQL CLOSE cursor3;
               return(SUCCESS);
          }

          if  (calc_sum2() == SUCCESS)
          {
              if  (strcmp(t_empno,empno) != 0)
                   s_count++;
               sprintf(t_empno,"%s",empno);
          }
          else
          {
               f_count++;
               printf("[집계단계2]에 실패한 EMPNO : %s \n", empno);
               /*sprintf(log_buff, "[집계단계2]에 실패한 EMPNO : %s \n", empno); dsa2000 Rexec 대체*/
                        /*Write_batlog(seqno++, log_buff); */
          }
     }
}

/**************************************************************************
  집계단계2를 처리한다.
 **************************************************************************/
calc_sum2()
{
     if  (strcmp(daykind,"1") == 0 )
     {
          EXEC SQL
          UPDATE  PKHOTSUM
             SET
                  OTGENHH = :s_tothh,
                  OTGENAMT = :s_ovtmamt
           WHERE  OVTMYYMM = :workmm AND EMPNO = :empno ;
          if  (sqlca.sqlcode != 0)
          {
               printf("ERROR_CODE : %d, 근무일자별 집계단계1 실패\n", sqlca.sqlcode);
               sprintf(log_buff, "ERROR_CODE : %d, 근무일자별 집계단계1 실패\n", sqlca.sqlcode); /*dsa2000 Rexec 대체*/
                        Write_batlog(seqno++, log_buff);
               return(FAIL);
          }
          return(SUCCESS);
     }

     if ((strcmp(daykind,"2") == 0) || (strcmp(daykind,"3") == 0) )
     {
          EXEC SQL
          UPDATE  PKHOTSUM
             SET
                  OTSATHH = :s_tothh,
                  OTSATAMT = :s_ovtmamt
           WHERE  OVTMYYMM = :workmm AND EMPNO = :empno ;
          if  (sqlca.sqlcode != 0)
          {
               printf("ERROR_CODE : %d, 근무일자별 집계단계2 실패\n", sqlca.sqlcode);
               sprintf(log_buff, "ERROR_CODE : %d, 근무일자별 집계단계2 실패\n", sqlca.sqlcode); /*dsa2000 Rexec 대체*/
               Write_batlog(seqno++, log_buff);
               return(FAIL);
          }
          return(SUCCESS);
     }

     if  (strcmp(daykind,"4") == 0 )
     {
          EXEC SQL
          UPDATE  PKHOTSUM
             SET
                  OTHOLIHH = :s_tothh,
                  OTHOLIAMT = :s_ovtmamt
           WHERE  OVTMYYMM = :workmm AND EMPNO = :empno ;
          if  (sqlca.sqlcode != 0)
          {
               printf("ERROR_CODE : %d, 근무일자별 집계단계3 실패\n",sqlca.sqlcode);
               sprintf(log_buff, "ERROR_CODE : %d, 근무일자별 집계단계3 실패\n", sqlca.sqlcode); /*dsa2000 Rexec 대체*/
               Write_batlog(seqno++, log_buff);
               return(FAIL);
          }
          return(SUCCESS);
     }
}
/****************************************************************************
  trail_spaces function.
 ****************************************************************************/
void trail_spaces(char *dest)
{
     int len,i,flag;

     len = strlen(dest);

     i    = 0;
     flag = 0;
     while (i < len)
     {
          if (*(dest+i) == ' ')
          {
               flag = 1;
               break;
          }
          else
            i++;
     }

     if  (flag)
         *(dest+i) = '\0';
     else
         *(dest+len) = '\0';
}
/****************************************************************************
  calc_term function.
 ****************************************************************************/
double  calc_term(char *frdate,char *todate)
{
     EXEC SQL BEGIN DECLARE SECTION;
          char  t1_date[9] = "";
          char  t2_date[9] = "";
          double  term;
     EXEC SQL END   DECLARE SECTION;

     strncpy(t1_date,frdate,8);
     strncpy(t2_date,todate,8);
     EXEC SQL
     SELECT  TO_DATE(:t2_date,'YYYYMMDD') - TO_DATE(:t1_date,'YYYYMMDD')
       INTO  :term
       FROM  DUAL;

     if  (sqlca.sqlcode != 0)
          return(FAIL);
     else
          return(term);
}

/*=== dsa2000 2004.11. Rexec대체 서비스를 위한 =====================================*/
int Write_batlog(int seqno, char *message)
{
     EXEC SQL AT log_db
     INSERT INTO PYBATLOG
     VALUES (:log_rundate, :log_progid, :seqno, :log_writeman, :message);

     if ((sqlca.sqlcode != 1403) && (sqlca.sqlcode != 0))
     {
          printf("ERROR_CODE : %d, pybatlog Insert Error. \n", sqlca.sqlcode);
          return(FAILURE);
     }

     EXEC SQL AT log_db COMMIT WORK ;
}

pre_PKHOTFWD()
{

    EXEC SQL BEGIN DECLARE SECTION;
        char tmp_empno[5];
        char tmp_workmm[7];
        char tmp_jobempno[5];

        int  count = 0, pre_count = 0;
        int  state = 0, pre_state = 0;

    EXEC SQL END DECLARE SECTION;

    strncpy(tmp_empno,empno,5);
    strncpy(tmp_workmm,workmm,7);
    strncpy(tmp_jobempno,jobempno,5);

    /* 당월 존재여부 체크 */
    EXEC SQL
    SELECT COUNT(*),max(STATE)
      INTO :count, :state
      FROM PKHOTFWD
     WHERE EMPNO    = :empno
       AND OVTMYYMM = :workmm
     ORDER BY EMPNO, OVTMYYMM, STATE;

    /* 전월 존재여부 체크 */
    EXEC SQL
    SELECT COUNT(*),max(STATE)
      INTO :pre_count, :pre_state
      FROM PKHOTFWD
     WHERE EMPNO    = :empno
       AND OVTMYYMM = :workmm-1
     ORDER BY EMPNO, OVTMYYMM, STATE;

    /* 당월 없으면 생성 */
    if (count == 0)
    {
        /* 전월 데이터도 없으면 모두 0 */
        if (pre_count == 0)
        {
            EXEC SQL
            INSERT INTO PKHOTFWD
            VALUES (:workmm, :empno, 1,
                    0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0,
                    TO_Char(sysdate,'YYYYMMDDHH24MISS'),:jobempno);

            if (sqlca.sqlcode != 0)
            {
                printf("ERROR_CODE : %d, PKHOTFWD 생성단계 실패\n", sqlca.sqlcode);
                sprintf(log_buff, "ERROR_CODE : %d, PKHOTFWD 생성단계 실패\n", sqlca.sqlcode); /*dsa2000 Rexec 대체*/
                Write_batlog(seqno++, log_buff);
                return(FAIL);
            }
            return(SUCCESS);

        }
        /* 전월 데이터 있으면 조회 후 전,당월 이월합에 Insert */
        else
        {
            EXEC SQL
            SELECT nvl(NXT_GENEXT, 0), nvl(NXT_HOLIEXT, 0), nvl(NXT_NIGHT, 0),
                   nvl(NXT_HOLI, 0), nvl(NXT_MEAL, 0), nvl(NXT_REST, 0), nvl(NXT_SPREST, 0)
              INTO :pre_genextsum, :pre_holiextsum, :pre_nightsum,
                   :pre_holisum, :pre_mealsum, :pre_restsum, :pre_sprestsum
              FROM PKHOTFWD
             WHERE EMPNO    = :empno
               AND OVTMYYMM = (:workmm-1);

            EXEC SQL
            INSERT INTO PKHOTFWD
            VALUES (:workmm, :empno, 1,
                    :pre_genextsum, :pre_holiextsum, :pre_nightsum, :pre_holisum, :pre_mealsum, :pre_restsum, :pre_sprestsum,
                    0, 0, 0, 0, 0, 0, 0,
                     TO_Char(sysdate,'YYYYMMDDHH24MISS'),:jobempno);

            if (sqlca.sqlcode != 0)
            {
              printf("ERROR_CODE : %d, PKHOTFWD 생성단계 실패\n", sqlca.sqlcode);
              sprintf(log_buff, "ERROR_CODE : %d, PKHOTFWD 생성단계 실패\n", sqlca.sqlcode); /*dsa2000 Rexec 대체*/
              Write_batlog(seqno++, log_buff);
              return(FAIL);
            }
        }
    }
    /* 당월 데이터가 있으면 집계위해 초기화 */
    else
    {
      if (state != 2)
      {
          /* 전월 데이터도 없으면 모두 0 */
          if (pre_count == 0)
          {
              EXEC SQL
              UPDATE PKHOTFWD
                 SET STATE           = 1
                    ,PRE_GENEXTSUM   = 0
                    ,PRE_HOLIEXTSUM  = 0
                    ,PRE_NIGHTSUM    = 0
                    ,PRE_HOLISUM     = 0
                    ,PRE_MEALSUM     = 0
                    ,PRE_RESTSUM     = 0
                    ,PRE_SPRESTSUM   = 0
                    ,WRITETIME       = TO_Char(sysdate,'YYYYMMDDHH24MISS')
                    ,WRITEMAN        = :jobempno
              WHERE EMPNO    = :empno
                AND OVTMYYMM = :workmm;

              if (sqlca.sqlcode != 0)
              {
                  printf("ERROR_CODE : %d, PKHOTFWD 초기화단계 실패\n", sqlca.sqlcode);
                  sprintf(log_buff, "ERROR_CODE : %d, PKHOTFWD 초기화단계 실패\n", sqlca.sqlcode); /*dsa2000 Rexec 대체*/
                  Write_batlog(seqno++, log_buff);
                  return(FAIL);
              }

          }
          /* 전월 데이터 있으면 조회 후 전,당월 이월합에 update */
          else
          {
              EXEC SQL
              SELECT nvl(NXT_GENEXT, 0), nvl(NXT_HOLIEXT, 0), nvl(NXT_NIGHT, 0),
                     nvl(NXT_HOLI, 0), nvl(NXT_MEAL, 0), nvl(NXT_REST, 0), nvl(NXT_SPREST, 0)
                INTO :pre_genextsum, :pre_holiextsum, :pre_nightsum,
                     :pre_holisum, :pre_mealsum, :pre_restsum, :pre_sprestsum
                FROM PKHOTFWD
               WHERE EMPNO    = :empno
                 AND OVTMYYMM = (:workmm-1);

              EXEC SQL
              UPDATE PKHOTFWD
                 SET STATE           = 1
                    ,PRE_GENEXTSUM   = :pre_genextsum
                    ,PRE_HOLIEXTSUM  = :pre_holiextsum
                    ,PRE_NIGHTSUM    = :pre_nightsum
                    ,PRE_HOLISUM     = :pre_holisum
                    ,PRE_MEALSUM     = :pre_mealsum
                    ,PRE_RESTSUM     = :pre_restsum
                    ,PRE_SPRESTSUM   = :pre_sprestsum
                    ,WRITETIME       = TO_Char(sysdate,'YYYYMMDDHH24MISS')
                    ,WRITEMAN        = :jobempno
              WHERE EMPNO    = :empno
                AND OVTMYYMM = :workmm;

              if (sqlca.sqlcode != 0)
              {
                  printf("ERROR_CODE : %d, PKHOTFWD 초기화단계 실패\n", sqlca.sqlcode);
                  sprintf(log_buff, "ERROR_CODE : %d, PKHOTFWD 초기화단계 실패\n", sqlca.sqlcode); /*dsa2000 Rexec 대체*/
                  Write_batlog(seqno++, log_buff);
                  return(FAIL);
              }
          }
      }
    }
}

print_Lastamt()
{

  EXEC SQL BEGIN DECLARE SECTION;
  	int last_ovtmamt, last_ovtmamt_Y = 0;
  EXEC SQL END DECLARE SECTION;

  EXEC SQL
  SELECT MAX(OVTMAMT), MAX(OVTMAMT_Y)
    INTO :last_ovtmamt, :last_ovtmamt_Y
    FROM
         (
         SELECT NVL(SUM(OVTMAMT),0) OVTMAMT,0 OVTMAMT_Y
           FROM PKHOTSUM
          WHERE OVTMYYMM = :workmm
            AND EMPNO >= :frempno AND EMPNO <= :toempno
            AND EMPNO NOT LIKE 'Y%'
         UNION
         SELECT 0,NVL(SUM(OVTMAMT),0)
           FROM PKHOTSUM
          WHERE OVTMYYMM = :workmm
            AND EMPNO >= :frempno AND EMPNO <= :toempno
            AND EMPNO LIKE 'Y%'
         )
  ;

  /* 정규직 초과근무 이월수당 합산 */
  printf("\n 정규직 전월 이월수당 합산 =======================");
  sprintf(log_buff, "\n 정규직 전월 이월수당 합산 ======================="); /*dsa2000 Rexec 대체*/
  Write_batlog(seqno++, log_buff);

  printf("\n 총 전월 이월수당 합산액 : %d \n",last_ovtmamt);
  sprintf(log_buff,"\n 총 전월 이월수당 합산액 : %d \n",last_ovtmamt); /*dsa2000 Rexec 대체*/
  Write_batlog(seqno++, log_buff);

  /* 계약직 초과근무 이월수당 합산 */
  printf("\n 계약직 전월 이월수당 합산 =======================");
  sprintf(log_buff, "\n 계약직 전월 이월수당 합산 ======================="); /*dsa2000 Rexec 대체*/
  Write_batlog(seqno++, log_buff);

  printf("\n 총 전월 이월수당 합산액 : %d \n",last_ovtmamt_Y);
  sprintf(log_buff,"\n 총 전월 이월수당 합산액 : %d \n",last_ovtmamt_Y); /*dsa2000 Rexec 대체*/
  Write_batlog(seqno++, log_buff);
}

void CreateLog()
{
     char  curdatetime[20+1]="";
     char  *logdir;
     logdir = hinsa_home();
     /*printf("logdir : %s", logdir);*/
     strcat(logdir,"/log/proc/pkg3071g_N/");        

     EXEC SQL
     SELECT TO_CHAR(SYSDATE,'YYYYMMDDHH24MISS')
       INTO   :curdatetime
       FROM   DUAL;

  /* 로그파일명을 세팅 */
     sprintf(logfile_fullname, "%sovtm%.12s.log", logdir, curdatetime);
     /* 로그파일 오픈 */
     fp = fopen(logfile_fullname, "w+");
     
     if  (fp == NULL) 
     {
          printf("로그파일오픈(%s) 에러\n", logfile_fullname);
          exit(1);
     }
     
     sprintf(log_buff, "초과근무 cron program [pkg3075g] 을 실행합니다. \n ");
     WriteLog(log_buff);
     Write_batlog(seqno++, log_buff); /*dsa2000 Rexec 대체*/
     
     sprintf(log_buff, "실행시간 : %.14s \n ",curdatetime);
     WriteLog(log_buff);
     Write_batlog(seqno++, log_buff); /*dsa2000 Rexec 대체*/
}


void WriteLog(char *message)
{
     fprintf(fp, "%s", message);
}
