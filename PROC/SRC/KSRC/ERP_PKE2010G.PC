/* ----------------------------------------------------------------------------
 PROGRAM-NAME   : ERP_PKE2010G(연차대상자 추출/계산-->ERP INTERFACE를 위한 프로그램) : 작업시간 10정도 소요.
 SYSTEM-NAME    : 급여
 SUBSYSTEM-NAME : 상여금
 Programmer     : 
 Version        : 1.00
 Date           : 2001.03.06.

[USING LIB]
MIS2 : /hper/insa/HINSA/common/lib/src/hperlib/avgpay.pc

Update Contents
  버전    수정일       수정자           관련근거       수정내용
  1.00    2001.03.06   유효성          설계명세서     최초개발본      
                                       ERP 미지급인건비 월별안분을 위해 연차를 
                                       임시테이블(ERP_PKMYEMAS)에 계산
                                       pke2010g.pc와 내용같고 사용하는 table이 다름 
 10.30    2002.10.18.  유효성          전2002-3755    전문계약직 추가     
 10.31    2004.02.24   강륜종          Oracle8i 업그레이드에 의한 관련 라이브러리 업그레이드.                            
 11.00    2004.06.18   강륜종(dsa2000) 직급코드값 변동에 따른 수정.   
                                 PAYCL코드 10이 사외이사에서 부장으로 변경.   사외이사는 0Z로 코드 변경.
 20.00    2004.12.     강륜종(dsa2000) Rexec대체 서비스를 위한 수정작업.
 20.00    2005.01.05.  dsa2000                 연차근무비율 80% 이상이면 10일 => 15일로 인상.
                연차근무비율 80% 이상 체크 안하도록 수정(무조건 15일 지급하게..이석희 대리 요청)
                근무기준일80% 미만자도 지급. 
 21.00    2005.01.13.  DSA2000                 정보통신수당(ITAMT) 추가. --2005년 01월부터 월차폐지후 신설.                
 22.00    2008.01.31.  dsa2000         미지급 연차수당 계산시 : 2/3 해제 및 일괄 2개씩 제외하여 추정
----------------------------------------------------------------------------- */

#include <stdio.h> 
#include <string.h> 
#include <stdlib.h>
#include <math.h>
#include <ctype.h>
#include <time.h>
#include "hinsa_macro.h"
#include "hinsa_string.h"
#include "hinsa_date.h"
#include "hinsa_log.h"
#include "hinsa_oracle.h"
#include "hinsa_common.h"

/*#define  SUCCESS     -1*/
#define  FAIL        -2

/*=== dsa2000 2004.12. Rexec대체 서비스를 위한 =============*/
char   log_rundate[16]     = ""; 
char   log_progid[16]      = "";
char   log_writeman[5]     = "";
char   log_buff[100]       = "";
int    seqno = 0; 

/********* Function Prototype 정의 ************/

float  get_sundaycnt(char*, char*);
float  get_dupholiday(char*,char*);
void   get_dayname(char *,char *);
void   get_payclkind(char *,char *);
void   add_days(char*,int,char*);
void   set_to_empdate(char *);
float  get_exdd();

float  get_ocaramt();
float  get_pay3sum();
float  get_bon12sum();
float  get_avggross();
float  get_commonpay(char *empno);
float  get_term(char *,char *);

void   process_gen();
void   delete_records();
void   gen_records();
float  get_yytotdd(char*,char*);
void   process_payclkind();
void   process_knte();
void   calc_yeamt();

/*********************************************
  Global Variable
**********************************************/
EXEC SQL BEGIN DECLARE SECTION;

     char   workyy[5]      = "";    /*   기준년도           */
     char   empno[5]       = "";    /*   사번               */
     char   korname[13]    = "";    /*   성명               */
     char   paycl[4]       = "";    /*   BAND               */
     float  paygr;                  /*   호봉               */
     char   paynum[3]      = "";    /*   급호차수           */
     char   orgnum[4]      = "";    /*   조직차수           */
     char   deptcode[7]    = "";    /*   부서코드           */
     char   payclkind[2]   = "";    /*   직제               */
     char   pstate[3]      = "";    /*   인사상태           */
     char   empdate[9]     = "";    /*   입사일             */
     char   payyn[2]       = "";    /*   급여지급여부       */
     char   yearyn[2]      = "";    /*   연차수당지급여부   */
                                    /*   연차계산기준       */
     char   yearkind[2]    = "";    /*   연차계산구분       */
     float  yytotdd;                /*   연간근로일수       */
     char   yyfrdate[9]    = "";    /*   근무기준일 from    */
     char   yytodate[9]    = "";    /*   근무기준일 to      */
     float  yybasedd;               /*   근무기준일수       */
                                    /*   연차일수           */
     float  yydeddd;                /*   연차공제일수       */
     float  yyexdd;                 
     float  yyrealdd;               /*   실근무일수         */
     float  yyate;                  /*   근무비율           */
     float  yearcredd;              /*   연차발생일수       */
                                    /*   가산일수            */
     float  dutytotdd;              /*   총근속일수         */
     float  dutyexdd;               /*   근속제외일수       */
     float  dutydeddd ;
     float  dutyrealdd;             /*   실근속일수         */
     float  yearadddd;              /*   연차가산일수       */
                                    /*   연차정산           */
     float  yeartotdd;              /*   연차대상일수       */
     float  yearusedd;              /*   연차사용일수       */
     float  yeardpsdd;              /*   연차적치일수       */
                                    /*   월차정산           */
     float  mondpsdd;               /*   월차적치일수       */
                                    /*   연월차정산         */
     float  ymdpsdd;                /*   연월차정산일수     */ 
                                    /*   수당계산           */
     float  pay3sum;                /*   3개월급여합        */
     float  bon12sum;               /*   12개월상여합       */
     float  avggross;               /*   평균임금           */
     float  commonpay;              /*   통상임금           */
     float  basepay;                /*   수당기준임금       */
     float  ymamt;                  /*   연월차수당         */
                                    /*   수당지급           */
     char   holdkind[2]    = "";    /*   유보방식           */
     float  holdrate;               /*   기준유보율         */
     float  holdamt;                /*   기준유보액         */
     float  realamt;                /*   실지급액           */
                                    /*   최종작업           */
     char   writetime[16]  = "";    /*   최종작업일시       */
     char   writeman[5]    = "";    /*   최종작업자         */
     char   jobstep[2]     = "";    /* 작업단계범위         */
     char   frempno[5]     = "";    /* 사번FROM             */
     char   toempno[5]     = "";    /* 사번TO               */
     char   halfyn[1+1]    = "";    /* 가정산[Y/N]           */
                                  
     char   bldcode[3]     = "";    /* 근무지코드            */
     float  trafdays;               /* 교통비지급일수  */  
     float  avgodamt;               /* 평균O/D 지원금  */
     char   baseyymm[6+1]  = "";
     char   ENDDATE[4+1]   = "";

EXEC SQL END DECLARE SECTION;
EXEC SQL INCLUDE SQLCA;

char  to_empdate[8+1]   = "";       /* 연차수당대상자의 기준입사일 */

int   s_count;
int   f_count;
      
int   id;

void main(int argc,char *argv[])
{
     char FL_file[255];
     
     if  (argc != 10) {  /* erp_pke2010g 2009 3 0000 XXXX 1 200901 D027 erp_pke2010g 2009110100000 */
          printf("[Usage] : erp_pke2010g 1.기준년도 2.작업구분[1.생성,2.계산,3.all] 3.사번fr 4.사번to \n");
          printf("[Usage] :              5.연차계산구분 6.기준월(최종급여반영월) 7.작업자 8.프로그램ID 9.시작시간 \n");
          exit(1);
     }     
     
     sprintf(workyy,"%s",  argv[1]);  
     sprintf(jobstep,"%s",  argv[2]);
     sprintf(frempno,"%s",  argv[3]);
     sprintf(toempno,"%s",  argv[4]);
     sprintf(yearkind,"%s",  argv[5]);
     sprintf(baseyymm,"%s",  argv[6]);
     sprintf(writeman,"%s",  argv[7]);  
     
     /*로그 디렉토리 생성 및 로그작업 */
     STRINIT(FL_file);
     strcpy(FL_file,"erp_pke2010g");
     
     hinsa_get_filename(1, FL_file);
     if  (hinsa_log_open(FL_file) == FAILURE)
     {
          hinsa_exit(0,"로그파일 생성에러로 인한 프로그램 종료...");
          return;
     }
     
     /* Dsa2000  2004.02.24.  **********************************/
     hinsa_log_print(0,"연차대상자 추출/계산 시작...");         
     hinsa_db_connect();  /*DB Connect 실시..*/
     /*dsa2000  수정..End......................................*/
     
     /*=== dsa2000 2004.12. Rexec대체 서비스를 위한 =============*/
     strcpy(log_writeman, argv[7]);
     strcpy(log_progid,   argv[8]);
     strcpy(log_rundate,  argv[9]);  
       
     EXEC SQL DECLARE log_db DATABASE;    
     hinsa_log_db_connect();
     /*========================================================*/
        
     sprintf(ENDDATE,"1231");    
             
     set_to_empdate(to_empdate);        
     
     if  (strcmp(jobstep,"1") == 0)
          process_gen();
     else if (strcmp(jobstep,"2") == 0)
          calc_yeamt();
     else
     {
          process_gen();
          calc_yeamt();
     }
     
     /* Dsa2000  2004.02.25.  hinsa_exit()에서 DB Commit & DB접속종료함.*/
     if  (sqlca.sqlcode != 0 && sqlca.sqlcode != 1403)
     {
          sprintf(log_buff, "ERROR ====== [작업 실패] =====");
          Write_batlog(seqno++, log_buff);                    /*dsa2000 Rexec 대체*/
          error_quit("[작업 실패]\n");
     }
     else
     {
          sprintf(log_buff, "OK ====== [연차생성/계산 작업성공] =====\n");
          Write_batlog(seqno++, log_buff);                  /*dsa2000 Rexec 대체*/
          hinsa_exit(0,"OK ====== [연차생성/계산 작업성공] =====\n");   
     }  
}

void process_gen()
{
     delete_records();
     gen_records();
     /*process_payclkind();*/
     process_knte();
} 

/*****************************************************************************
  기존의 자료를 삭제하는 함수.
 *****************************************************************************/
void delete_records()
{
     EXEC SQL
     delete   from erp_pkmyemas
     where  empno >= :frempno and empno <= :toempno;  
     if ((sqlca.sqlcode != 0) && (sqlca.sqlcode != 1403)) 
     {
          print_errmsg(sqlca.sqlcode,"ERP_PKMYEMAS  자료삭제오류...");
          Write_batlog(seqno++, "ERP_PKMYEMAS  자료삭제오류...");        /*dsa2000 Rexec 대체*/
          error_quit("작업실패...");
     }
}

/*****************************************************************************
  set_to_empdate function
 *****************************************************************************/
void set_to_empdate(char *to_empdate)
{
     float  totdd, i, j;
     float  k = 0;
     char   t1_date[8+1]  = "";
     char   t2_date[8+1]  = "";
     char   buf[50+1]  = "";
     
     sprintf(t1_date,"%s",workyy);
     sprintf(t2_date,"%s",workyy);
     sprintf(t1_date+4,"0101");
     sprintf(t2_date+4,ENDDATE);
     totdd = get_yytotdd(t1_date,t2_date);
     totdd = ceil(totdd * 0.1);
     
     i = j = 0;
     while (j < totdd)
     {
          get_dayname(t1_date,buf); /* printf("\n t1_date[%s]",t1_date);   for test */
          i = is_holiday(t1_date);
          if  (k == FAIL)
               error_quit("작업실패...");
          if ((strcmp(buf,"SUNDAY") != 0) && (i == 0))
               j++;
          add_days(t1_date,1,t1_date);
         
     }
     add_days(t1_date,-1,t1_date);
     sprintf(to_empdate,"%.8s",t1_date);
}

/*****************************************************************************
  is_holiday() function.
 *****************************************************************************/
is_holiday(char *pdate)
{
     EXEC SQL BEGIN DECLARE SECTION;
          int   count;
          char  t_date[8+1] = "";
     EXEC SQL END DECLARE SECTION;
     sprintf(t_date,"%s",pdate);
     
     EXEC  SQL
     select  count(*)
       into  :count
       from  pkcholi  
      where  holidate = :t_date 
        and  holikind <> '0' ;
     if  (sqlca.sqlcode != 0)
     {
          print_errmsg(sqlca.sqlcode,"휴일테이블 읽기오류...");
          Write_batlog(seqno++, "휴일테이블 읽기오류...");  /*dsa2000 Rexec 대체*/
          printf(" 대상날짜 : [%s] \n",t_date);
          return(FAIL);
     }
     return(count);
}

/*****************************************************************************
  연차수당 대상자를 생성하는 함수.
 *****************************************************************************/
void  gen_records()
{
      EXEC SQL BEGIN DECLARE SECTION;
           float  count;
           char   t_empdate[8+1] = "";
      EXEC SQL END DECLARE SECTION;
     
      char  t1_date[8+1]  = "";
      char  t2_date[8+1]  = "";
     
      /*******************************
      급호차수가 급여마스터에 존재... 
      EXEC SQL
      SELECT  CPAYNUM
      INTO  :paynum
      FROM  PKCPBAS;
      if (sqlca.sqlcode != 0)
      {
        print_errmsg(sqlca.sqlcode,"현급호차수 읽기오류...");
        error_quit("작업실패...");
      }
      *******************************/
     
      sprintf(t1_date,"%s",workyy);
      sprintf(t2_date,"%s",workyy);
      sprintf(t1_date+4,"0101");
      sprintf(t2_date+4,ENDDATE);
      yytotdd = get_yytotdd(t1_date,t2_date);
      if  (yytotdd == FAIL)
           error_quit("작업실패...");
     
      sprintf(t_empdate,"%s",to_empdate);
     
      printf("입사기준일 : --->  %s\n", t_empdate);
      
      EXEC SQL 
      insert into erp_pkmyemas(
             workyy,  empno,    korname,  paycl,   paygr,     
             empdate, 
             paynum,  orgnum,   deptcode, pstate,  payyn,     yearkind,  yytotdd)
      select :workyy, a.empno,  a.korname,  a.paycl,   a.paygr,     
             CASE WHEN  (a.EMPNO >= '2601' AND a.EMPNO <=  '2721') /* 2013.05.23.hjku 미디어 입사자 처리.. 김창수M 요청*/
                      OR(a.EMPNO >= 'J075' AND a.EMPNO <=  'J080') /* 2013.05.23.hjku 미디어 입사자 처리.. 김창수M 요청*/
/* 2017.01.03 eyha 임단협 관련 후속조치 - 무기계역직 사번 체계 변경 처리 J078만 재직 나머지는 퇴사 J078 -> 2969 김재겸 통화함 - 사번변경해서 반영요청*/           
                      OR(a.EMPNO  = '2969')  
                      OR(a.EMPNO >= 'P669' AND a.EMPNO <= 'P684') /* 2013.05.23.hjku 미디어 입사자 처리.. 김창수M 요청*/                                                         
                  THEN a.GROUPEMPDATE 
                  ELSE a.empdate                                                   
                   END empdate, 
             a.paynum,  a.orgnum,
             /* decode(substr(c.tribegb,1,1),'2',c.deptcode, b.deptcode ) deptcode,  /* 이상용 20181114 */
             Case When (XX.Tribegb='2' And YY.Tribegb='2') Then YY.deptcode Else XX.deptcode End  deptcode, /* 20181204 JHG 조직개편 */
             a.pstate,  a.payyn,     :yearkind, :yytotdd
       from  pkmpmas a, 
             /* pycdept b, pycdept c    /* 이상용 20181114 */
            (Select Orgnum, Deptcode, Fincode, Substr(Tribegb,1,1) Tribegb From Pycdept ) XX,  /* 20181204 JHG 조직개편 */  
            (Select Orgnum, Deptcode, Fincode, Substr(Tribegb,1,1) Tribegb From Pycdept ) YY   /* 20181204 JHG 조직개편 */              
      where (empno >= :frempno and empno <= :toempno)
        AND (XX.Deptcode = a.Deptcode AND XX.ORGNUM = a.ORGNUM)  /* 20181204 JHG 조직개편 */  
        AND (YY.Deptcode = a.Jobdept  AND YY.ORGNUM = a.ORGNUM)  /* 20181204 JHG 조직개편 */      	
      /*	and  a.orgnum   = b.orgnum(+)
      	and  a.deptcode = b.deptcode(+)
      	and  a.orgnum   = c.orgnum(+)
      	and  a.jobdept  = c.deptcode(+) */
      /*==========================================================================
        10.30    2002.08.28.  유효성  전2002-3755    전문계약직 추가 
      ===========================================================================*/  
      /*and   ((paycl between '11' and '93')  or paycl ='E1') /*20001.1. 계약직 포함*/
      /*2004.06.18 강륜종(dsa2000) 직급코드값 변동에 따른 수정.  
      and   ((paycl between '11' and '93')  or paycl ='E1' or paycl ='C1') */
      /*infra and   ((paycl between '10' and '93')  or paycl ='E1' or paycl ='C1')  */
        and ((a.paycl between 'C11' and 'D41')  or a.paycl ='H11' or a.paycl ='D91')  
        and (a.pstate < '80');
      /*and  empdate <= :t_empdate;  dsa2000 2005.01.06. 근무기준일80% 미만자도 지급하기 위해 막음...*/
      
      if  (sqlca.sqlcode != 0)
      {
           print_errmsg(sqlca.sqlcode,"연차대상자 생성오류...");
           Write_batlog(seqno++, "연차대상자 생성오류...");  /*dsa2000 Rexec 대체*/
           error_quit("작업실패...");
      }
     
      /* 2002.1.7. 유효성 주석처리 start --> 인사팀 요청 
      EXEC SQL DECLARE c5 CURSOR FOR
      select  empno
      from  erp_pkmyemas
      where  workyy = :workyy
      order by empno;
     
      EXEC SQL OPEN c5;
      if ((sqlca.sqlcode != 1403) && (sqlca.sqlcode != 0) && (sqlca.sqlcode != -1405)) 
      {
        print_errmsg(sqlca.sqlcode,"Cursor c5 Open Error...");
        EXEC SQL CLOSE c5;
        error_quit("작업실패...");
      }
      
      while(1)
      {
        EXEC SQL FETCH c5
        INTO  :empno;
        if (sqlca.sqlcode == 1403) 
        {
         EXEC SQL CLOSE c5;
         return;
        }
        else if (sqlca.sqlcode != 0)
        {
         print_errmsg(sqlca.sqlcode,"Cursor c5 Data Fetch Error...");
         EXEC SQL CLOSE c5;
         error_quit("작업실패...");
        } 
        
        EXEC SQL
        select  count(*)
        into  :count
        from  pkhphis
        where  substr(paydate,1,4) = :workyy and empno = :empno;
        if (sqlca.sqlcode != 0)
        {
         print_errmsg(sqlca.sqlcode,"월급여이력 Check Error...");
         EXEC SQL CLOSE c5;
         error_quit("작업실패...");
        }
     
        if (count == 0)
        {
         EXEC SQL
         delete  from erp_pkmyemas
         where  workyy = :workyy and empno = :empno;
         if (sqlca.sqlcode != 0)
         {
           print_errmsg(sqlca.sqlcode,"연차대상자 중 월급여이력 미존재자 삭제실패...");
           EXEC SQL CLOSE c5;
           error_quit("작업실패...");
         }
        }
      }
2002.1.7. 유효성 주석처리 end --> 인사팀 요청 */  
}

/*****************************************************************************
  연간근로일수를 구하는 함수.  
 *****************************************************************************/
float get_yytotdd(char *frdate, char *todate)
{
     EXEC SQL BEGIN DECLARE SECTION;
          float count;
          char  t1_date[8+1] = "";
          char  t2_date[8+1] = "";
     EXEC SQL END DECLARE SECTION;
     
     float  result = 0.0;  
     float  tmp  = 0.0 ;
     
     sprintf(t1_date,"%s",frdate);
     sprintf(t2_date,"%s",todate);
     result = get_term(t1_date,t2_date);
     
     EXEC  SQL
     select  count(*)
       into  :count
       from  pkcholi  
      where  (holidate >= :t1_date and holidate <= :t2_date) 
        and   holikind <> '0' ;
     if  (sqlca.sqlcode != 0)
     {
          print_errmsg(sqlca.sqlcode,"당해년도 휴일총일수 읽기오류...");
          Write_batlog(seqno++, "당해년도 휴일총일수 읽기오류...");  /*dsa2000 Rexec 대체*/
          return(FAIL);
     }
     
     if ((tmp=get_dupholiday(frdate,todate)) == FAIL)
          return(FAIL);  
       
       
     result = result - (count + get_sundaycnt(frdate,todate)-tmp);    
     
     return(result);
}

/*****************************************************************************
  기준년도의 일요일수를 구하는 함수.
 *****************************************************************************/
float get_sundaycnt(char *frdate, char *todate)
{
     char   fr_date[8+1]   = ""; 
     char   to_date[8+1]   = "";
     char   buf[50]        = "";
     float  tmp;
     float  count;
    
     sprintf(fr_date,"%s",frdate);
     sprintf(to_date,"%s",todate);
     while(1)
     {
          get_dayname(fr_date,buf);
          if  (strcmp(buf,"SUNDAY") == 0)
               break;
          add_days(fr_date,1,fr_date);  
     }
    
     while(1)
     {
          get_dayname(to_date,buf);
          if  (strcmp(buf,"SUNDAY") == 0)
               break;
          add_days(to_date,-1,to_date);
     }
    
     count = floor(get_term(fr_date,to_date) / 7) + 1;
     return(count);
}

/*****************************************************************************
  근태에 등록된 휴일 중 일요일의 수를 구하는 함수.
 *****************************************************************************/
float get_dupholiday(char *frdate,char *todate)
{
     EXEC SQL BEGIN DECLARE SECTION;
          float  count;
          char  t1_date[8+1]   = "";
          char  t2_date[8+1]   = "";
          char  holidate[8+1]  = "";
          char  buf[50+1]      = "";
     EXEC SQL END DECLARE SECTION;
    
     sprintf(t1_date,"%s",frdate);
     sprintf(t2_date,"%s",todate);
     EXEC SQL DECLARE c4 CURSOR FOR
     select  holidate
       from  pkcholi
      where  (holidate >= :t1_date and holidate <= :t2_date) 
        and   holikind <> '0'
     order  by holidate;
    
     EXEC SQL OPEN c4;
     if ((sqlca.sqlcode != 1403) && (sqlca.sqlcode != 0) && (sqlca.sqlcode != -1405)) 
     {
          print_errmsg(sqlca.sqlcode,"Cursor c4 Open Error...");
          EXEC SQL CLOSE c4;
          return(FAIL);
     }
     
     count = 0;
     while(1)
     {
          EXEC SQL FETCH c4
          INTO  :holidate;
          if  (sqlca.sqlcode == 1403) 
          {
               EXEC SQL CLOSE c4;
                
               return(count);
          }
          else if (sqlca.sqlcode != 0)
          {
               print_errmsg(sqlca.sqlcode,"Cursor c4 Data Fetch Error...");
               EXEC SQL CLOSE c4;
               return(FAIL);
          }
          
          get_dayname(holidate,buf);
          if  (strcmp(buf,"SUNDAY") == 0)
               count++;  
     }  
}

/****************************************************************************
       요일명을 구하는 함수.
 ***************************************************************************/
void get_dayname(char *indate,char *result)
{
     EXEC SQL BEGIN DECLARE SECTION;
          char idate[8+1]     = "";
          char ddname[20]     = "";
     EXEC SQL END   DECLARE SECTION;
     int count;
     
     sprintf(idate,"%s",indate);
     EXEC SQL 
     select  to_char(to_date(:idate,'YYYYMMDD'),'DAY')
       into  :ddname
       from  dual;
     
     count = 0;
     while (ddname[count] != ' ')
          count++;
     ddname[count] = '\0';
     sprintf(result,"%s",ddname);
}

/*****************************************************************************
  연차테이블에 직제를 반영하는 함수.
 *****************************************************************************/
void  process_payclkind()
{

      EXEC SQL DECLARE c1 CURSOR FOR
      select  empno, korname, paycl
        from  erp_pkmyemas
       where  empno >= :frempno and empno <= :toempno
      order by empno;
     
      EXEC SQL OPEN c1;
      if ((sqlca.sqlcode != 1403) && (sqlca.sqlcode != 0) && (sqlca.sqlcode != -1405)) 
      {
           EXEC SQL CLOSE c1;
           print_errmsg(sqlca.sqlcode,"Cursor c1 Open Error...");
           EXEC SQL CLOSE c1;
           error_quit("작업실패...");
      }
      
      while(1)
      {
           EXEC SQL FETCH c1
           INTO  :empno, :korname, :paycl;
         
           if  (sqlca.sqlcode == 1403) 
           {
                EXEC SQL CLOSE c1;
                return;
           } 
           else if (sqlca.sqlcode != 0)
           {
                print_errmsg(sqlca.sqlcode,"Cursor c1 Data Fetch Error...");
                EXEC SQL CLOSE c1;
                error_quit("작업실패...");
           }
           
           get_payclkind(paycl,payclkind);  
           if  (strcmp(payclkind,"*") == 0)
           {
                EXEC SQL CLOSE c1;
                return;
           }
           else
           {
                EXEC SQL
                update  erp_pkmyemas
                   set  payclkind = :payclkind
                 where  empno = :empno;
                if  (sqlca.sqlcode != 0)
                {
                     print_errmsg(sqlca.sqlcode,"직제 Update Error...");
                     EXEC SQL CLOSE c1;
                     error_quit("작업실패...");
                }
           }
      }
}

/*****************************************************************************
  직제를 구하는 함수.
 *****************************************************************************/
void get_payclkind(char *kind,char *result)
{
     /*  =======================================================================
       연봉제에 의한 수정
     
       if ((strcmp(kind,"10") >= 0) && (strcmp(kind,"99") <= 0))
        sprintf(result,"1");
       else if ((strcmp(kind,"A1") >= 0) && (strcmp(kind,"A9") <= 0))
        sprintf(result,"2");
       else
       {
        printf(" %s (%s) 에 대한 직제코드값을 구할 수 없습니다.\n",
        korname,empno);
        sprintf(result,"*");  
       }
       =======================================================================   */
     if ((strcmp(kind,"11") >= 0) && (strcmp(kind,"93") <= 0))
          sprintf(result,"1");
     else
     {
          printf(" %s (%s) 에 대한 직제코드값을 구할 수 없습니다.\n", korname,empno);
          sprintf(log_buff, " %s (%s) 에 대한 직제코드값을 구할 수 없습니다.\n", korname,empno);
          Write_batlog(seqno++, log_buff);  /*dsa2000 Rexec 대체*/
          sprintf(result,"*");  
     }
}

/*****************************************************************************
  근태관련사항를 처리하는 함수.
 *****************************************************************************/
void process_knte()
{
     EXEC SQL DECLARE c2 CURSOR FOR
     select  empno, korname, empdate, yytotdd 
       from  erp_pkmyemas
      where  empno >= :frempno and empno <= :toempno
      order by empno;
     
     EXEC SQL OPEN c2;
     if ((sqlca.sqlcode != 1403) && (sqlca.sqlcode != 0) && (sqlca.sqlcode != -1405)) 
     {
          print_errmsg(sqlca.sqlcode,"Cursor c2 Open Error...");
          EXEC SQL CLOSE c2;
          error_quit("작업실패...");
     }
     
     while(1)
     {
          EXEC SQL FETCH c2
          INTO  :empno, :korname, :empdate, :yytotdd;
        
          if  (sqlca.sqlcode == 1403) 
          {
               EXEC SQL CLOSE c2;
               return;
          }
          else if (sqlca.sqlcode != 0)
          {
               print_errmsg(sqlca.sqlcode,"Cursor c2 Data Fetch Error...");
               EXEC SQL CLOSE c2;
               error_quit("작업실패...");
          }
        
          if  (set_knteitems() != SUCCESS)
          {
               EXEC SQL CLOSE c2;
               error_quit("작업실패...");
          }
          s_count++;
     }
}

/*****************************************************************************
  근태관련사항를 구하는 함수.
 *****************************************************************************/
set_knteitems()
{
     EXEC SQL BEGIN DECLARE SECTION;
          char   t_date[8+1]   = "";
          float  count;
          float  tempcnt;
     EXEC SQL END DECLARE SECTION;
    
     char basedate[8+1] = "";
     
     sprintf(basedate,"%s",workyy);
     sprintf(basedate+4,"0101");
     
     if  (strcmp(empdate,basedate) <= 0)   /* 근무기준일FROM  */
          sprintf(yyfrdate,"%s",basedate);
     else
          sprintf(yyfrdate,"%s",empdate);
    
     sprintf(basedate+4,ENDDATE);     /* 근무기준일TO  */
     sprintf(yytodate,"%s",basedate);
    
     yybasedd = get_yytotdd(yyfrdate,yytodate);   /* 근무기준일수  */
     if  (yybasedd == FAIL)
          error_quit("작업실패...");
    
     EXEC  SQL        /* 연차공제일수  */
     select  ymdedcnt  
       into  :yydeddd
       from  pkhdusum
      where  empno = :empno and duyy = :workyy;  
     if ((sqlca.sqlcode != 0) && (sqlca.sqlcode != 1403))
     {
          print_errmsg(sqlca.sqlcode,"연차공제일수 읽기오류...");
          printf(" %s (%s) 에 대한 연간근태내역을 구할 수 없습니다.\n", korname,empno);
          sprintf(log_buff, " %s (%s) 에 대한 연간근태내역을 구할 수 없습니다.\n", korname,empno);
          Write_batlog(seqno++, log_buff);  /*dsa2000 Rexec 대체*/
          return(FAIL);
     }
     else if (sqlca.sqlcode == 1403)
          yydeddd = 0;
       
    yyexdd = get_exdd() ;
     
    yyrealdd = yybasedd - yydeddd - yyexdd ;  /* 실근무일수  */ 
     
    yyate    = ceil((yyrealdd / yytotdd * 100)*100)/100 ;  /* 근무비율  */ 
     
     /*dsa2000   2005.01.05.  연차기본발생일 10일=>15일로 증가, 80%이상 무조건 15일로 (월차폐지로 인하여) */
     /* 연차발생일수  */ 
     /*if (yyate == 100)      
       yearcredd = 10;
     else if ((yyate < 100) && (yyate >= 90)) 
       yearcredd = 8;
     else if (yyate < 90) 
       yearcredd = 0;
     else
     {
       printf(" %s (%s) 에 대한 근무비율값에 이상이 있습니다. \n",korname,empno);
       return(FAIL);
     }  */
     
     yearcredd = 15;   /*모든사원 기본으로 15개 지급함.(80% 조항 삭제)  dsa2000  2005.01.06.*/
    
     dutytotdd = get_term(empdate,yytodate);   /* 총근속일수  */
    
     /* 근속제외일수   */
     /* 근속제외 당년 12.31 이후까지 등록된 경우 당해년도 12.31까지만 계산함. */
     EXEC SQL  /*select  nvl(sum(exdays),0)*/
     select  nvl(sum(to_date(least(:workyy||'1231',extodate),'YYYYMMDD') - 
             to_date(exfrdate,'YYYYMMDD') +1),0)
       into  :dutyexdd
       from  pkhexdd
      where  empno = :empno   
        and upper(exfixyn) = 'Y' ;
    
     if  (sqlca.sqlcode != 0)
     {
          print_errmsg(sqlca.sqlcode,"근속제외일수 읽기오류...");
          printf(" %s (%s) 에 대한 근속제외일수를 구할 수 없습니다.\n",korname,empno);
          sprintf(log_buff," %s (%s) 에 대한 근속제외일수를 구할 수 없습니다.\n", korname,empno);
          Write_batlog(seqno++, log_buff);  /*dsa2000 Rexec 대체*/
          return(FAIL);
     }
     
     /*2002.1.7. 유효성 추가 start */
     EXEC  SQL      
     select  count(*)
       into  :tempcnt
       from  pkhdusum
      where  empno = :empno and duyy <= :workyy;  
     if ((sqlca.sqlcode != 0) && (sqlca.sqlcode != 1403))
     {
          print_errmsg(sqlca.sqlcode,"tempcnt 읽기오류...");
          printf(" %s (%s) 에 대한 tempcnt내역을 구할 수 없습니다.\n", korname,empno);
          sprintf(log_buff," %s (%s) 에 대한 tempcnt내역을 구할 수 없습니다.\n", korname,empno);
          Write_batlog(seqno++, log_buff);  /*dsa2000 Rexec 대체*/
          return(FAIL);
     }
     
     if  (tempcnt != 0)
     {     
          EXEC  SQL        /* 연차공제일수  */
           select  sum(nvl(ymdedcnt,0))  
             into  :dutydeddd
             from  pkhdusum
            where  empno = :empno and duyy = :workyy;  
          if ((sqlca.sqlcode != 0) && (sqlca.sqlcode != 1403))
          {
               print_errmsg(sqlca.sqlcode,"연차공제일수 읽기오류...");
               printf(" %s (%s) 에 대한 연간근태내역을 구할 수 없습니다.\n", korname,empno);
               sprintf(log_buff," %s (%s) 에 대한 연간근태내역을 구할 수 없습니다.\n", korname,empno);
               Write_batlog(seqno++, log_buff);  /*dsa2000 Rexec 대체*/
               return(FAIL);
          }
          else if (sqlca.sqlcode == 1403)
               dutydeddd = 0;
     }
     else  dutydeddd = 0 ; 
     
     dutyrealdd = dutytotdd - dutyexdd - dutydeddd ;   /* 실근속일수  */
    
     /* 연차가산일수  */ 
     if  (yearcredd > 0)
          yearadddd  = floor(dutyrealdd/365) - 1;
     else
          yearadddd = 0;  
        
     if  (yearadddd <= 0) 
          yearadddd = 0;   
           
     yeartotdd = yearcredd + yearadddd;   /* 연차대상일수  */
     
     /*2013.05.23.hjku. 최대 연차일수(25일) 반영...김창수M 요청*/
     if(yeartotdd > 25 ) yeartotdd = 25;

     
     EXEC SQL        /* 연차사용일수  */
     select  nvl(year,0)+nvl(yearhalf,0) * .5    /* select  year   */
       into  :yearusedd
       from  pkhdusum
      where  empno = :empno 
        and duyy = :workyy;
     if ((sqlca.sqlcode != 0) && (sqlca.sqlcode != 1403))
     {
          print_errmsg(sqlca.sqlcode,"연차사용일수 읽기오류...");
          printf(" %s (%s) 에 대한 연차사용일수를 구할 수 없습니다.\n",korname,empno);
          sprintf(log_buff," %s (%s) 에 대한 연차사용일수 구할 수 없습니다.\n", korname,empno);
          Write_batlog(seqno++, log_buff);  /*dsa2000 Rexec 대체*/
          return(FAIL);
     }
     else if (sqlca.sqlcode == 1403)
           yearusedd = 0; 
     
     yeardpsdd = yeartotdd - yearusedd;   /* 연차적치일수  */ 
     
     /* 월차적치일수   dsa2000  2006.01. 월차폐지로 삭제 *
     EXEC SQL
     select  mondpsdd
     into  :mondpsdd
     from  pkhmohis
     where  empno = :empno 
           and     workyymm = (  
       select   max(workyymm)
       from  pkhmohis
       where  empno = :empno 
                   and     substr(workyymm,1,4) = :workyy);
     if ((sqlca.sqlcode != 0) && (sqlca.sqlcode != 1403))
     {
       print_errmsg(sqlca.sqlcode,"월차이력화일 읽기오류...");
       printf(" %s (%s) 에 대한 월차이력화일이 존재하지 않습니다.\n",korname,empno);
       sprintf(log_buff," %s (%s) 에 대한 월차이력화일이 존재하지 않습니다.\n", korname,empno);
       Write_batlog(seqno++, log_buff); 
       return(FAIL);
     }
     else if (sqlca.sqlcode == 1403)
       mondpsdd = 0;
     ***********************************************************************************************/
     
     ymdpsdd = yeardpsdd + mondpsdd;       /* 연월차정산일수 */
     if  (mondpsdd < 0)
     {   
          if  (ymdpsdd < 0)
               ymdpsdd = 0;
         
          /* *****************
          EXEC SQL
          UPDATE  PKHMOHIS
          SET  MONCRESUM   = 0,
            MONUSESUM   = 0,
            MONGIVESUM   = 0,
            MONDPSDD  = 0
          WHERE  EMPNO = :empno AND WORKYYMM = :t_date;
          if (sqlca.sqlcode != 0)
          {  print_errmsg(sqlca.sqlcode,"월차이력화일 Update Error...");
            printf("실패한 사람 :  %s [%s] \n",korname,empno);
            return(FAIL);
          }************************ */
     }
     
/*printf("DEBUG : empno=[%s],yyfrdate[%f],yytodate[%f],yybasedd[%f],yydeddd[%f],yyrealdd[%f],yyate[%f],yearcredd[%f],dutytotdd[%f],dutyexdd[%f],dutyrealdd[%f],yeartotdd[%f],yearadddd[%f],yearusedd[%f],yeardpsdd[%f],mondpsdd[%f],ymdpsdd[%f]\n",
             empno,yyfrdate,yytodate,yybasedd,yydeddd,yyrealdd,yyate,yearcredd,dutytotdd,dutyexdd,dutyrealdd,yeartotdd,yearadddd,yearusedd,yeardpsdd,mondpsdd,ymdpsdd);     
*/     
     EXEC  SQL
     update  erp_pkmyemas
        set  yyfrdate    = :yyfrdate,
             yytodate    = :yytodate,
             yybasedd    = :yybasedd,
             yydeddd     = :yydeddd + :yyexdd ,
             yyrealdd    = :yyrealdd,
             yyate      = :yyate,
             yearcredd   = :yearcredd,
             dutytotdd   = :dutytotdd,
             dutyexdd    = :dutyexdd + :dutydeddd,
             dutyrealdd  = :dutyrealdd,
             yeartotdd  = :yeartotdd,
             yearadddd  = :yearadddd,
             yearusedd  = :yearusedd,
             yeardpsdd  = :yeardpsdd,
             mondpsdd  = :mondpsdd,
             ymdpsdd   = :ymdpsdd,
             writeman  = :writeman,
             writetime  = to_char(sysdate,'YYYYMMDDHH24MISSD')
      where  empno = :empno;
     if  (sqlca.sqlcode != 0)
     {
          print_errmsg(sqlca.sqlcode,"연차내역화일 Update Error1...");
          printf("실패한 사람 :  %s [%s] \n",korname,empno);
          sprintf(log_buff," %s (%s) 에 대한 연차내역 업데이트 실패...\n", korname,empno);
          Write_batlog(seqno++, log_buff);  /*dsa2000 Rexec 대체*/
          return(FAIL);
     }
     return(SUCCESS);
}

/*****************************************************************************
  연차수당을 계산하는 함수.  
 *****************************************************************************/
void  calc_yeamt()
{
      EXEC SQL
      select  trafdays
      into  :trafdays
      from  pkcmcbas;  
      if  (sqlca.sqlcode != 0) 
      {
           print_errmsg(sqlca.sqlcode,"식교비지급기준 읽기오류...");
           Write_batlog(seqno++, "식교비지급기준 읽기오류...");  /*dsa2000 Rexec 대체*/
           error_quit("작업실패...");
      }
      
      EXEC SQL 
      select   avgodamt
        into   :avgodamt
        from   pkcpbas;
      if  (sqlca.sqlcode != 0) 
      {
           print_errmsg(sqlca.sqlcode,"급여지급기준 읽기오류...");
           sprintf(log_buff," %s (%s) 에 대한 tempcnt내역을 구할 수 없습니다.\n", korname,empno);
           Write_batlog(seqno++, "급여지급기준 읽기오류...");  /*dsa2000 Rexec 대체*/
           error_quit("작업실패...");
      }
     
      s_count = 0;
     
      EXEC SQL DECLARE c3 CURSOR FOR
      select  empno, nvl(empdate,'00000000'), ymdpsdd, paycl, yeartotdd  /*dsa2000  yeartotdd 추가 2006.02.02. */
        from  erp_pkmyemas 
       where  empno >= :frempno and empno <= :toempno
         and empno <> 'P571'
       order by empno;
     
      EXEC SQL OPEN c3;
      if ((sqlca.sqlcode != 1403) && (sqlca.sqlcode != 0) && (sqlca.sqlcode != -1405)) 
      {
           print_errmsg(sqlca.sqlcode,"Cursor c3 Open Error...");
           EXEC SQL CLOSE c3;
           error_quit("작업실패...");
      }
     
      while(1)
      {
           EXEC SQL FETCH c3
           INTO  :empno, :empdate, :ymdpsdd, :paycl, :yeartotdd;   /*dsa2000  yeartotdd 추가 2006.02.02. .*/
          
           if  (sqlca.sqlcode == 1403) 
           {
                EXEC SQL CLOSE c3;
                return;
           }
           else if (sqlca.sqlcode != 0)
           {
                print_errmsg(sqlca.sqlcode,"Cursor c3 Data Fetch Error...");
                EXEC SQL CLOSE c3;
                error_quit("작업실패...");
           }
          
          /*  =======================================================================
           연봉제에 의한 수정
          
             pay3sum = get_pay3sum();
             if (pay3sum == FAIL) 
             {  
                 EXEC SQL CLOSE c3;
                 error_quit("작업실패...");
             }
          
             bon12sum  = get_bon12sum();
             if (bon12sum == FAIL) 
             {  
                 EXEC SQL CLOSE c3;
                 error_quit("작업실패...");
             }
           =======================================================================   */
            
           get_avgpay(empno,baseyymm,empdate,&avggross);
                 
           if  (avggross == FAIL) 
           {  
                EXEC SQL CLOSE c3;
                error_quit("작업실패...");
           }
          
           commonpay = get_commonpay(empno);
           if  (commonpay == FAIL) 
           {  
                EXEC SQL CLOSE c3;
                error_quit("작업실패...");
           }
           
           if  (avggross > commonpay)
                basepay = avggross;
           else
                basepay = commonpay; 
           
           /* dsa2000  2006.02.02.  
              2006년분 연차수당부터는 최대 2/3까지의 일수만 연차수당 지급이 됨으로 
              총연차일수에서 1/3 만큼의 일수 차감하여 인터페이스 되도록 수정 
              ymamt = ceil( basepay * 8 / 184 * ceil(yeartotdd*2/3) );*/
           /*2013.05.13.hjku.. 삭제 김창수M 요청
           ymdpsdd = ymdpsdd - 2;  // 2008.01. 2/3 해제 및 일괄 2개씩 제외하여 추정 ..김한수 차장 요청. 
           */
          //   ymamt   = ceil( basepay * 8 / 184 * ymdpsdd );   
          
          //2017.01.02 eyha 연차수당 규정 변경 통상시간 184 -> 209, 기준임금 -> 통상임금
          //ymamt   = ceil( basepay * 8 / 184  * ymdpsdd ); 
          ymamt   = ceil( commonpay * 8 / 209  * ymdpsdd ); 
            
            EXEC SQL 
            update  erp_pkmyemas
               set  pay3sum     = 0, 
                    bon12sum    = 0,
                    avggross    = :avggross, 
                    commonpay   = :commonpay,
                    basepay     = :basepay, 
                    ymamt       = :ymamt,
                    writeman    = :writeman, 
                    writetime   = to_char(sysdate,'YYYYMMDDHH24MISSD') 
             where  empno      = :empno;
            
            if  (sqlca.sqlcode != 0)
            {
                 print_errmsg(sqlca.sqlcode, "연차수당내역 Update Error2...");
                 sprintf(log_buff," %s : 연차수당내역 Update Error2...", sqlca.sqlcode);
                 Write_batlog(seqno++, "급여지급기준 읽기오류...");  /*dsa2000 Rexec 대체*/
                 EXEC SQL CLOSE c3;
                 error_quit("작업실패...");
            }
            s_count++;
      }
}

/*****************************************************************************
  3개월 급여합을 구하는 함수. : 사용안함.
 *****************************************************************************/
float get_pay3sum()
{
     EXEC SQL BEGIN DECLARE SECTION;
          char   t1_date[7] = "";
          char   t2_date[7] = "";
          float  sum;
          float  count;
     EXEC SQL END DECLARE SECTION;
     float  tmp;
    
     add_months(baseyymm,-2,t1_date);
     add_months(baseyymm,0,t2_date);
    
     count = 0;
     EXEC SQL
     SELECT   COUNT(*)
     INTO  :count
     FROM  PKHPHIS
     WHERE  EMPNO = :empno   
       AND (PAYDATE >= :t1_date AND PAYDATE <= :t2_date );   
     if  (sqlca.sqlcode != 0)
     {
          print_errmsg(sqlca.sqlcode,"3개월급여합 읽기오류1...");
          printf("3개월급여합 읽기오류1 실패한 사람 :  %s [%s] \n",korname,empno);
          sprintf(log_buff,"3개월급여합 읽기오류1 실패한 사람 :  %s [%s] \n",korname,empno);
          Write_batlog(seqno++, log_buff);  /*dsa2000 Rexec 대체*/
          return(FAIL);
     }  
    
     if  (count == 0)
          return(0);
    
     
    
     EXEC SQL 
     SELECT  SUM(NVL(BASICAMT,0)+NVL(INFOAMT,0)+NVL(DUTYAMT,0)+
             NVL(BBASICAMT,0)+NVL(BINFOAMT,0)+NVL(BDUTYAMT,0)+
             NVL(MATEAMT,0)+NVL(PARTAMT,0)+NVL(CHILDAMT,0)+
             NVL(OVTMAMT,0)+NVL(SPTMAMT,0)+NVL(MCARAMT,0)+
             NVL(LICEAMT,0)+NVL(MBONAMT,0)+NVL(SOPAY,0)+NVL(ITAMT,0) )
       INTO  :sum
       FROM  PKHPHIS
      WHERE  EMPNO = :empno   
        AND (PAYDATE >= :t1_date AND PAYDATE <= :t2_date);     
     if  (sqlca.sqlcode != 0)
     {
          print_errmsg(sqlca.sqlcode,"3개월급여합 읽기오류2...");
          printf("3개월급여합 읽기오류2 실패한 사람 :  %s [%s] \n",korname,empno);
          sprintf(log_buff,"3개월급여합 읽기오류2 실패한 사람 :  %s [%s] \n",korname,empno);
          Write_batlog(seqno++, log_buff);  /*dsa2000 Rexec 대체*/
          return(FAIL);
     }
    
     tmp = get_ocaramt();
     if  (tmp == FAIL)
          return(FAIL);
    
    
     return(sum + tmp);
}

/*****************************************************************************
  3개월급여합에서의 자가운전지원금을 처리하는 함수.  
 *****************************************************************************/
float  get_ocaramt()
{
     EXEC SQL BEGIN DECLARE SECTION;
          char   t_date[7] = "";
          float  trafamt;
          float  tmp[3];
          float  count;
     EXEC SQL END DECLARE SECTION;
     int i;
    
     for (i = 0;i < 3; i++)
     {
          add_months(baseyymm,-i,t_date);
          EXEC SQL
          SELECT  COUNT(*)  
            INTO  :count  
            FROM  PKHPHIS
           WHERE  EMPNO = :empno AND PAYDATE = :t_date;   
          if  (sqlca.sqlcode != 0)
          {
               print_errmsg(sqlca.sqlcode,"3개월급여합에서의 자가운전지원금 읽기오류1...");
               printf("실패한 사람 :  %s [%s] \n",korname,empno);
               sprintf(log_buff,"자가운전지원금 읽기오류1 실패한 사람 :  %s [%s] \n",korname,empno);
               Write_batlog(seqno++, log_buff);  /*dsa2000 Rexec 대체*/
               return(FAIL);
          }
          
          
          if  (count > 0)
          {
               EXEC SQL
               SELECT   ODAMT
                 INTO  :tmp[i]
                 FROM  PKHPHIS
                WHERE  EMPNO = :empno 
                  AND PAYDATE = :t_date;
               if  (sqlca.sqlcode != 0)
               {
                    print_errmsg(sqlca.sqlcode,
                                            "3개월급여합에서의 자가운전지원금 읽기오류2...");
                    printf("실패한 사람 :  %s [%s] \n", korname,empno);
                    sprintf(log_buff,"자가운전지원금 읽기오류2 실패한 사람 :  %s [%s] \n",korname,empno);
                    Write_batlog(seqno++, log_buff);  /*dsa2000 Rexec 대체*/
                    return(FAIL);
               }
    
     /* ****************************
                    EXEC SQL 
        SELECT  NVL(TRAFAMT,0)
        INTO  :trafamt
        FROM  PKCPBLD
        WHERE  BLDCODE = :bldcode;
    
        if (sqlca.sqlcode != 0)
        {
          printf(" Module Name : get_ocaramt() \n"); 
          printf(" TABLE ID : PKCPBLD \n"); 
          printf(" SQL STATEMENT : SELECT \n");
          return(FAIL);
        }
    **************************** */
    
            if  (tmp[i] > 0)
                 tmp[i] = avgodamt;
            else
                 tmp[i] = 0;
       }
       else
            tmp[i] = 0;
     }
    
     return(tmp[0]+tmp[1]+tmp[2]);
}

/*****************************************************************************
  12개월간 상여합을 구하는 함수.  
 *****************************************************************************/
float  get_bon12sum()
{
     EXEC SQL BEGIN DECLARE SECTION;
          char   t1_date[7] = "";
          char   t2_date[7] = "";
          char   tmp[7]     = "";
          float  sum;
          float  count;
     EXEC SQL END DECLARE SECTION;
    
     add_months(baseyymm,-11,t1_date);
     add_months(baseyymm,0,t2_date);
    
     EXEC SQL
     SELECT  SUM(NVL(BONUSAMT,0)+NVL(INCENTAMT,0)+NVL(TRAINAMT,0)+
           /*NVL(WINTERAMT,0)+NVL(HOMESUPAMT,0)+NVL(YBONAMT12,0)+NVL(SOBON,0)) dsa2000  2006.04.19. WINTERAMT 삭제 영업인세티브 평균임금 미포함.*/ 
             NVL(HOMESUPAMT,0) + NVL(YBONAMT12,0) + NVL(SOBON,0)
          )
       INTO  :sum
       FROM  PKHPHIS
       WHERE  EMPNO = :empno   
         AND (PAYDATE >= :t1_date AND PAYDATE <= :t2_date);  
     if  (sqlca.sqlcode != 0)
     {
          print_errmsg(sqlca.sqlcode,"12개월상여합 읽기오류1...");
          printf("실패한 사람 :  %s [%s] \n",korname,empno);
          sprintf(log_buff,"12개월상여합 읽기오류1... 실패한 사람 :  %s [%s] \n",korname,empno);
          Write_batlog(seqno++, log_buff);  /*dsa2000 Rexec 대체*/
          return(FAIL);
     }
     return(sum);
}
/*****************************************************************************
  평균임금을 구하는 함수.
 *****************************************************************************/
float get_avggross()
{
     EXEC SQL BEGIN DECLARE SECTION;
          char   t1_date[9] = "";
          char   t2_date[9] = "";
          char   basedate[9] = "";
          float  result;
     EXEC SQL END DECLARE SECTION;
    
     int  index;
    
     add_months(baseyymm,-12,t1_date); 
     add_months(baseyymm,-3,t2_date);  
       
     sprintf(t1_date+6,"15");
     sprintf(t2_date+6,"15");
     sprintf(basedate,"%.4s%s",workyy,ENDDATE);
    
     if  (strcmp(empdate,t1_date) <= 0)
          index = 1;
     else if ((strcmp(empdate,t1_date) >  0) && 
                    (strcmp(empdate,t2_date) <= 0))
          index = 2;
     else
          index = 3;
    
    
     switch (index)
     {
          case 1 :
          {
               result = ceil(pay3sum/3) + ceil(bon12sum/12);
               break;  
          }
          case 2 :/* 6개월*/
          { 
               result = ceil(pay3sum/3) + 
               ceil(bon12sum/
               get_term(empdate,basedate)*30);
               break;
          }  
          case 3 :  /* 3개월*/
          {
               result = ceil((pay3sum + bon12sum) / 
               get_term(empdate,basedate)*30);
               break;
          }  
     }
    
     return(result);
}

/*****************************************************************************
  시작일과 종료일까지의 기간을 일단위로 구하는 함수.  
 *****************************************************************************/
float get_term(char *frdate, char *todate)
{
     EXEC SQL BEGIN DECLARE SECTION;
          char   t1_date[8+1] = "";
          char   t2_date[8+1] = "";
          float  result;
     EXEC SQL END DECLARE SECTION;
    
     sprintf(t1_date,"%s",frdate);
     sprintf(t2_date,"%s",todate);
    
     EXEC SQL
     SELECT  TO_DATE(:t2_date,'YYYYMMDD') - TO_DATE(:t1_date,'YYYYMMDD') + 1
       INTO  :result
       FROM  DUAL;
    
     return(result);
} 
/*****************************************************************************
  통상임금을 구하는 함수.
 *****************************************************************************/
float  get_commonpay(char *empno)
{
     EXEC SQL BEGIN DECLARE SECTION;
          float  result;
     EXEC SQL END DECLARE SECTION;
    
     result = 0;
     
     EXEC SQL
     /* select   ceil(realtotpay/23) */    
/*     select   ceil(totpay/18)       통상임금변경 /23 -> /18 로 변경함 kth 2009.03.11 */
     select   CEIL((TOTPAY + TONGAMT1 + TONGAMT2 + TONGAMT3) /12)     /*  2014.11.17 하은영 통상임금 규정변경으로 인한 시스템 적용 (18 -> 12, 통상임금, 통상임금수당도 포함)  */
       into   :result
       from   pkhyphis
      where   empno = :empno 
        and  yearpaynum = (select to_char(yearpaynum) from pkcpbas);
     if ((sqlca.sqlcode != 0) && (sqlca.sqlcode !=1403))
     {
          printf("get_commonpay() -> 통상임금 Read Error 99999 \n"); 
          printf("[ERROR_CODE] : (%d),(%s) \n",sqlca.sqlcode,empno);
          sprintf(log_buff,"get_commonpay() -> 통상임금 Read Error 999999999999 :  %s \n",sqlca.sqlcode);
          Write_batlog(seqno++, log_buff);  /*dsa2000 Rexec 대체*/
          return(FAIL);
     }
    
     if  (sqlca.sqlcode == 1403)
     {
          printf(" empno : [%s]의 해당년도 연봉자료가 존재하지 않음...\n",empno);
          sprintf(log_buff," empno : [%s]의 해당년도 연봉자료가 존재하지 않음...\n",empno);
          Write_batlog(seqno++, log_buff);  /*dsa2000 Rexec 대체*/
          result = 0;
     }
    
     return(result); 
}

/*****************************************************************************
  기준일+M 일을 구하는 함수.
 *****************************************************************************/
void add_days(char* indate,int m, char* rdate)
{
     EXEC SQL BEGIN DECLARE SECTION;
          char   t_date[8+1]  = "";
          float  t_adddays;
     EXEC SQL END DECLARE SECTION;
     
     sprintf(t_date,"%s",indate);
     t_adddays = m;
     
     EXEC SQL
     SELECT   TO_CHAR(TO_DATE(TO_CHAR(TO_DATE(:t_date,'YYYYMMDD')+
              :t_adddays,'YYYYMMDD'),'YYYYMMDD'),'YYYYMMDD')
       INTO   :t_date
       FROM   DUAL;
     
     sprintf(rdate,"%s",t_date);
}

/* ****************************************************************************
  get_exdd function.
 **************************************************************************** */
float   get_exdd()
{
     EXEC SQL BEGIN DECLARE SECTION;
          char  t_exfrdate[8+1]   = "";
          char  t_extodate[8+1]   = "";
          float count;
     EXEC SQL END DECLARE SECTION;
     
     char  t1[8+1];
     char  t2[8+1];
     float  exdays;
     float  tmp  = 0.0 ;
     
     sprintf(t1,"%.4s0101",workyy);
     sprintf(t2,"%.4s%s",workyy,ENDDATE);
     
     EXEC SQL DECLARE c6 CURSOR FOR
     SELECT  EXFRDATE, EXTODATE
       FROM  PKHEXDD
      WHERE  EMPNO = :empno      
        AND UPPER(EXFIXYN) = 'Y'   
        AND (SUBSTR(EXFRDATE,1,4) = :workyy  OR
             SUBSTR(EXTODATE,1,4) = :workyy  OR    
             :workyy between substr(exfrdate,1,4) and 
             SUBSTR(EXTODATE,1,4));
     
     EXEC SQL OPEN c6;
     if ((sqlca.sqlcode != 1403) && (sqlca.sqlcode != 0) && (sqlca.sqlcode != -1405)) 
     {
          print_errmsg(sqlca.sqlcode,"Cursor c6 Open Error...");
          printf(" %s (%s) 에 대한 근속제외일수 읽기오류...\n", korname,empno);
          sprintf(log_buff," %s (%s) 에 대한 근속제외일수 읽기오류...\n", korname,empno);
          Write_batlog(seqno++, log_buff);  /*dsa2000 Rexec 대체*/
          EXEC SQL CLOSE c6;
          error_quit("작업실패...");
     }
     
     exdays = 0;
     while(1)
     {
          EXEC SQL FETCH c6
          INTO  :t_exfrdate, :t_extodate;
          if  (sqlca.sqlcode == 1403) 
          {
               EXEC SQL CLOSE c6;
               return(exdays);
          }
          else if (sqlca.sqlcode != 0)
          {
               print_errmsg(sqlca.sqlcode,"Cursor c6 Data Fetch Error...");
               printf(" %s (%s) 에 대한 근속제외일수 읽기오류...\n", korname,empno);
               sprintf(log_buff," %s (%s) 에 대한 근속제외일수 읽기오류...\n", korname,empno);
               Write_batlog(seqno++, log_buff);  /*dsa2000 Rexec 대체*/
               EXEC SQL CLOSE c6;
               error_quit("작업실패...");
          } 
          
          if ((strcmp(t_exfrdate,t1) >= 0) && (strcmp(t_extodate,t2) <= 0))
          {
               exdays += get_term(t_exfrdate,t_extodate);
            
               EXEC  SQL
               select  count(*)
                 into  :count
                 from  pkcholi  
                where  (holidate >= :t_exfrdate and holidate <= :t_extodate) 
                  and   holikind <> '0' ;
               if (sqlca.sqlcode != 0)
               {
                   print_errmsg(sqlca.sqlcode,"당해년도 휴일총일수 읽기오류1...");
                   sprintf(log_buff," %s : 당해년도 휴일총일수 읽기오류1..\n", sqlca.sqlcode);
                   Write_batlog(seqno++, log_buff);  /*dsa2000 Rexec 대체*/
                   return(FAIL);
               }
               
               if ((tmp=get_dupholiday(t_exfrdate,t_extodate)) == FAIL)
                    return(FAIL);  
               
               
               exdays = exdays - (count + get_sundaycnt(t_exfrdate,t_extodate)-tmp);      
          }   
          
          else if ((strcmp(t_exfrdate,t1) >= 0) && (strcmp(t_extodate,t2) > 0))
          {
               exdays += get_term(t_exfrdate,t2);
                        
               EXEC  SQL
               select  count(*)
                 into  :count
                 from  pkcholi  
                where  (holidate >= :t_exfrdate and holidate <= :t2) 
                  and  holikind <> '0' ;
               if  (sqlca.sqlcode != 0)
               {
                    print_errmsg(sqlca.sqlcode,"당해년도 휴일총일수 읽기오류1...");
                    return(FAIL);
               }
               
               if ((tmp=get_dupholiday(t_exfrdate,t2)) == FAIL)
                    return(FAIL);     
               
               exdays = exdays - (count + get_sundaycnt(t_exfrdate,t2)-tmp);      
            
          }   
             
          else if ((strcmp(t_exfrdate,t1) < 0) && (strcmp(t_extodate,t2) <= 0))
          {
               exdays += get_term(t1,t_extodate);
               
               EXEC  SQL
               select   count(*)
                 into   :count
                 from   pkcholi  
                where  (holidate >= :t1 and holidate <= :t_extodate) 
                  and   holikind <> '0' ;
             
               if  (sqlca.sqlcode != 0)
               {
                    print_errmsg(sqlca.sqlcode,"당해년도 휴일총일수 읽기오류1...");
                    return(FAIL);
               }
               
               if ((tmp=get_dupholiday(t1,t_extodate)) == FAIL)
                    return(FAIL);      
               
               exdays = exdays - (count + get_sundaycnt(t1,t_extodate)-tmp); 
           }
             
          else if ((strcmp(t_exfrdate,t1) < 0) && (strcmp(t_extodate,t2) > 0))
          {
               exdays += get_term(t1,t2);
               
                EXEC  SQL
                select  count(*)
                  into  :count
                  from  pkcholi  
                 where  (holidate >= :t1 and holidate <= :t2) 
                   and   holikind <> '0' ;
                if  (sqlca.sqlcode != 0)
                {
                     print_errmsg(sqlca.sqlcode,"당해년도 휴일총일수 읽기오류1...");
                     return(FAIL);
                }
               
                if ((tmp=get_dupholiday(t1,t2)) == FAIL)
                     return(FAIL);     
               
                exdays = exdays - (count + get_sundaycnt(t1,t2)-tmp); 
                
          }  
     }
}

/*=== dsa2000 2004.12. Rexec대체 서비스를 위한 =====================================*/
int   Write_batlog(int seqno, char *message)
{  
      EXEC SQL AT log_db 
      INSERT INTO PYBATLOG
      VALUES (:log_rundate, :log_progid, :seqno, :log_writeman, :message);
      
      if ((sqlca.sqlcode != 1403) && (sqlca.sqlcode != 0)) 
      {  
           printf("ERROR_CODE : %d, pybatlog Insert Error. \n", sqlca.sqlcode);   
           return(FAIL);
      }                        
                          
      EXEC SQL AT log_db COMMIT WORK ;  
}
                                                                                   